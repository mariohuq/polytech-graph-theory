# Введение {-}

## Постановка задачи {-}

### Лабораторная работа 1 {-}

1. Сформировать случайным образом связный ациклический граф, выходные степени вершин которого подчиняются
   распределению Пойя 1 (параметры распределения задаются как константы),
   с необходимым количеством вершин.
   <!-- Распределение лучше всего брать из справочника Вадзинского (есть в списке литературы). -->
2. Реализовать метод Шимбелла на полученном графе
   (пользователь вводит количество ребер).
3. Определить возможность построения маршрута от одной заданной точки до другой
   (вершины вводит пользователь) и указывать количество таковых маршрутов.

### Лабораторная работа 2 {-}

1. Для заданных графов (случайно сгенерированных в предыдущей работе)
   найти кратчайший путь для выбранных точек, используя алгоритмы Дейкстры, Беллмана-Форда, Флойда
   (пользователь вводит номера вершин начальной и конечной).
   Для алгоритмов Дейкстры и Беллмана-Форда рекомендуется выводить вектор расстояний,
   для Флойда-Уоршалла --- матрицу расстояний. Обязательно выводить сам путь в виде последовательности вершин.
2. Сравнить скорости работы данных алгоритмов (по количеству итераций).

### Лабораторная работа 3 {-}

1. Сформировать связный ациклический граф случайным образом в соответствии с заданным распределением.
	 На его основе построить матрицы пропускных способностей и стоимости.

2. Для полученного графа найти максимальный поток по алгоритму
	 Форда-Фалкерсона (или любого из перечисленных в лекции).

3. Вычислить поток минимальной стоимости (в качестве величины потока брать значение,
	 равное $\frac 2 3 f_{\max}$, где $f_{\max}$ --- максимальный поток).
	 Использовать ранее реализованные алгоритмы Дейкстры и/или Беллмана–Форда.

### Лабораторная работа 4 {-}

1. Для заданных графов (случайно сгенерированных в первой работе)
		построить минимальный по весу остов, используя алгоритмы Прима и Краскала.
		<!-- (алгоритм Борувки - факультативно) -->
		Сравнить данные алгоритмы (итерации).

2. Используя матричную теорему Кирхгофа, найти число остовных деревьев в графе.

3. Полученный остов закодировать с помощью кода Прюфера
		(проверить правильность кодирования декодированием).
		Желательно сохранять веса при кодировании.

### Лабораторная работа 5 {-}

1. Для заданных графов (случайно сгенерированных в первой работе) проверить,
		является ли граф эйлеровым и гамильтоновым. Если граф не является таковым,
		то отдельно модифицировать граф до эйлерова и отдельно до гамильтонова
		(до полного графа можно дополнять только в крайнем случае!).

2. Построить эйлеров цикл.

3. Решить задачу коммивояжёра на гамильтоновом графе
		(все гамильтоновы циклы с суммарным весом выводить либо на экран,
		если их мало, либо в файл).

# Математическое описание

Неориентированным графом $G(V,E)$ называется совокупность двух множеств ---
непустого множества _вершин_ $V$ и множества _рёбер_ $E$,
\begin{gather*}
G(V, E) ≝ ⟨V;E⟩,
\\ V ≠ ∅,
\\ E ⊂ 2^V ∧ ∀e ∈ E (|e| = 2).
\end{gather*}

Ориентированным графом $G(V,E)$ называется совокупность двух множеств ---
непустого множества _узлов_ $V$ и множества _дуг_ $E$,
\begin{gather*}
G(V, E) ≝ ⟨V;E⟩,\\ V ≠ ∅,\quad E ⊂ V^2.
\end{gather*}

Число вершин графа $G$ обозначим $p$, а число рёбер — $q$:
\begin{gather*}
p ≝ p(G) ≝ |V|,\\
q ≝ q(G) ≝ |E|.
\end{gather*}

<!-- степень вершины? -->

## Связность

_Маршрутом_ в графе называется чередующаяся последовательность вершин и рёбер,
начинающаяся и кончающаяся вершиной, $v_0, e_1, v_1, e_2, v_2,\dotsc, e_k, v_k$, в которой
любые два соседних элемента инцидентны, причём однородные элементы (вершины,
рёбра) через один смежны или совпадают.

Если $v_0 = v_k$, то маршрут _замкнут_, иначе — _открыт_. Если все рёбра различны,
то маршрут называется _цепью_. Если все вершины (а значит, и рёбра) различны,
то маршрут называется _простой цепью_.

Говорят, что две вершины в графе _связаны_, если
существует соединяющая их (простая) цепь. Граф, в
котором все вершины связаны, называется _связным_.

Отношение связанности вершин является эквивалентностью.
Классы эквивалентности по отношению связанности называются _компонентами связности_ графа.

Число компонентов связности графа $G$ обозначается
$k(G)$.

Граф $G$ связный $⟺ k(G) = 1$.

Если $k(G) > 1$, то $G$ — _несвязный_ граф.

Замкнутая цепь называется _циклом_; замкнутая простая цепь называется _простым
циклом_. Число циклов в графе $G$ обозначается $z(G)$. Граф без циклов называется
ациклическим ($z(G) = 0$).

## Метод Шимбелла {#shim_math}

Пусть граф задан матрицей $Ω = (ω_{ij})$ весов ребер, т.е.
$$ ω_{ij} = \begin{cases}
	0, & \text{если вершины }i, j\text{ не смежны},\\
	ω, & \text{если вес ребра }ij = ω.
\end{cases}
$$

Введем специальные операции над элементами матрицы
смежности вершин, позволяющие находить кратчайшие или максимальные пути между
вершинами,
состоящие из заданного количества ребер. Эти операции таковы.

1) Операция умножения двух величин $a$ и $b$ при возведении матрицы в степень
соответствует их алгебраической сумме, то есть
	$$ \begin{cases}
   	a ⋅ b ≝ a+b\\
   	a ⋅ 0 = 0 ⋅ a ≝ 0
 	\end{cases}
	$$

2) Операция сложения двух величин $a$ и $b$ заменяется выбором из этих величин
минимального (максимального) элемента, то есть
	\begin{equation}
	\begin{cases}
		a+b ≝ \min (\max)\{a, b\}\\
		a + 0 = 0 + a ≝ a
	\end{cases}\label{eq:shimbell_mul}
	\end{equation} 

	нули при этом игнорируются. Минимальный или максимальный элемент выбирается из
	ненулевых элементов. Нуль в результате операции (\ref{eq:shimbell_mul}) может быть получен лишь тогда,
	когда все элементы из выбираемых --- нулевые.

С помощью этих операций длины кратчайших или максимальных путей между всеми
вершинами определяется возведением в степень весовой матрицы $Ω$, содержащей веса
ребер. Например, элементы матрицы $Ω^2 =\left(ω^{(2)}_{ij}\right)$ определяются следующим образом
$$ ω^{(2)}_{ij} = \min_k (\max_k) \left\{ω^{(1)}_{ik} + ω^{(1)}_{kj}\right\}.
$$

Аналогично определяются элементы матрицы $Ω^m =\left(ω^{(m)}_{ij}\right)$.
Длина кратчайшего или максимального пути из $m$ ребер от вершины $i$ до вершины $j$ равна $ω^{(m)}_{ij}$[@shaporev2006].

## Распределение Пойа 1

Ряд распределения дискретной случайной величины $X$ --- совокупность
всех ее возможных значений $x_1,\dotsc,x_n$, и вероятностей $p_1,\dotsc,p_n$, появления каждого из этих значений.

Примем как обозначение $∏\limits_{k=0}^{-1} f(k) = 1$ (как произведение пустого множества элементов).

Ряд распределение Пойа ---

$$ p(x) = C_n^x \frac {∏\limits_{k=0}^{x-1} (b+kc) ∏\limits_{k=0}^{n-x-1} (r+kc)} {∏\limits_{k=0}^{n-1}(b + r + kc)},
\ x=0,1,2,\dotsc, n.
$$	

В частности,
$$
p(0) = ∏_{k=0}^{n-1} \frac {r + kc}
         {b + r + kc},
\quad
p(n) = ∏_{k=0}^{n-1} \frac {b + kc}
         {b + r + kc},
$$

где $n>0$, $b>0$, $r>0$, $c ∈ ℤ$. Параметр $c$ может быть отрицательным,
однако он должен удовлетворять условию $b+r+c(n-1)>0$[@vadzinsky2001].

\begin{figure}[tb]
	\centering
	\includegraphics[]{img/polya_1_vadzinski.png}
	\caption{Функция вероятности распределения Пойа 1.\\
	Параметры распределения:\\
	\textit{а} — $n=5$, $b=3$,   $r=20$, $c=1$;\\
	\textit{б} — $n=5$, $b=140$, $r=20$, $c=1$;\\
	\textit{в} — $n=5$, $b=12$,  $r=20$, $c=1$;\\
	\textit{г} — $n=5$, $b=20$,  $r=20$, $c=1$.}
	\label{fig:polya_1_vadzinski}
\end{figure}

\begin{figure*}
\pgfplotstableread{
0   0.5294  0.0000  0.1102  0.0404
1   0.3266  0.0007  0.2858  0.1548
2   0.1147  0.0158  0.3111  0.3031
3   0.0252  0.1023  0.2086  0.3003
4   0.0038  0.3576  0.072   0.1654
5   0.0003  0.5236  0.0123  0.036
}{\mydata}
\newcommand*\plothyst[2]{%
\begin{subfigure}[b]{0.475\textwidth}
\centering
\caption{#2}%
\begin{tikzpicture}
\begin{axis}[
    xlabel={$x$}, ylabel={$p(x)$},
    axis lines=middle,
    x axis line style={-},
    y axis line style={-},
    x label style={below},
    y label style={left},
    clip=false,
    ybar,
    bar width=10pt,
    ticklabel style = {font=\footnotesize},
    xtick=data,
    tick align=inside,
    ymax=0.55,
    xmax=5.5
]
\addplot[red,fill=red, fill opacity=0.3] table[y index=#1]\mydata;
\end{axis}
\end{tikzpicture}%
%\label{fig:}
\end{subfigure}%
}
\captionsetup[subfigure]{labelformat=simple}
\centering%
\plothyst{1}{}\hfill%
\plothyst{2}{}\vskip\baselineskip%
\plothyst{3}{}\hfill%
\plothyst{4}{}%
\caption{ Функция вероятности распределения (по выборке $N=10\,000$).\\
Параметры распределения такие же, как на рис. \ref{fig:polya_1_vadzinski}.
}%
\label{fig:real_hystograms}
\let\plothyst\relax
\let\mydata\relax
\end{figure*}

\begin{algorithm}
  \caption{Генерации случайного числа, подчиняющегося распределению Пойа 1}
  \label{alg:poja}
\begin{algorithmic}
\Require $n>0$, $b>0$, $r>0$, $c ∈ ℤ$
\Ensure случайное число из множества $\{0,1,\dotsc, n\}$
\State $p := p_0$
\Comment{$p_0 = p(0)$}
\State $r :=$ \Call{Rand}{}
\Comment{$r ∈ [0, 1]⊂ℝ$, случайное с равномерным распределением}
\For{$x := 0,n-1$}
	\State $r := r - p$
	\If{$r < 0$}
		\State \Return $x$
	\EndIf
	\State $p := p ⋅ α(x)$
	\Comment{$α(x) = \dfrac {(n+1-x)\left(b + (x-1)c\right)}{x \left(r + (n-x)\right) c}$}
\EndFor
\State \Return $n$
\end{algorithmic}
\end{algorithm}

## Вспомогательные процедуры

Во многих алгоритмах поиска кратчайших путей используются две процедуры.
Процедура инициализации \textsc{Init}($s$) строит начальное состояние матрицы длин путей
и матрицы предшествования.

\begin{algorithmic}
\Require узел $s$
\Ensure заполненные матрицы $T$ :\Array{1..$p$, 1..$p$}{\Real} длин путей и\\
 $Π$: \Array{1..$p$, 1..$p$}{0..$p$} самих путей.
\Procedure{Init}{$s$}
\For{$v := 1,p$}
\State $T [v] := +∞$, $Π[v] := 0$
\EndFor
\State $T[s] := 0$
\EndProcedure
\end{algorithmic}

Процедура ослабления, или релаксации, — \textsc{Relax}($s$, $v$, $u$) проверяет, возможно ли
улучшить известный путь из узла $s$ в узел $v$, проведя новый путь через узел $u$,
и обновляет пути, если это возможно.

\begin{algorithmic}
\Require узлы $s$, $v$, $u$\\
матрица $W$ : \Array{1..$p$, 1..$p$}{\Real} длин дуг,\\
матрица $T$ : \Array{1..$p$, 1..$p$}{\Real} длин путей,\\
матрица $Π$ : \Array{1..$p$, 1..$p$}{0..$p$} самих путей.
\Ensure обновленные матрицы $T$, $Π$
\Procedure{Relax}{$s$, $v$, $u$}
\If {$T [s, v] > T [s, u] + W [u, v]$}
\State $T [s, v] := T [s, u] + W [u, v]$; $Π[s, v] := u$ \Comment{новый путь короче}
\EndIf
\EndProcedure
\end{algorithmic}

Восстановление пути по матрице предшествования $Π$ можно произвести так:
<!-- 389 -->

\begin{algorithmic}
\State $w := v$; \Yield $w$ \Comment{последний узел}
\While{$w ≠ u$}
	\State $w := Π[u, w]$
	\State \Yield $w$ \Comment{предыдущий узел}
\EndWhile
\end{algorithmic}

Полученную последовательность можно обратить, если это потребуется, и получить прямой
порядок узлов пути.

## Алгоритм Дейкстры {#Dijkstra}

Алгоритм Дейкстры \ref{alg:dijkstra} находит кратчайший путь между двумя данными вершинами
(узлами) в (ор)графе, если длины дуг неотрицательны[@novikov2008].

_Сложность алгоритма_: $𝒪\left((p+q)\log p\right)$ при условии, что $Q$ --- бинарная куча (сложность \textsc{ExtractMin} --- $𝒪(\log p)$).

\begin{algorithm}
  \caption{Дейкстры поиска кратчайших путей}\label{alg:dijkstra}
  \begin{algorithmic}
  \Require
  	взвешенный орграф $G(V, E)$,\\
  	матрица весов $W$ : \Array{1..$p$, 1..$p$}{\Real},\\
		источник $s$.
  \Ensure
  	вектор $T$ : \Array{1..$p$}{\Real} длин кратчайших путей от источника,\\
  	вектор $Π$ : \Array{1..$p$}{0..$p$} самих путей.
  \State \Call{Init}{$s$} \Comment{инициализация}
  \State $Q:=V$ \Comment{контейнер (очередь с приоритетами)}
  \While{$Q≠∅$}
		\State $u$ := \Call{ExtractMin}{$Q$} \Comment{извлечение узла с минимальным значением $T[u]$}
		\If{$T[u] = ∞$} \Stop \EndIf \Comment{остальные узлы недостижимы из $s$}
		\ForAll{$v ∈ Γ(u)$}
			\If{$v ∈ Q$}
				\State \Call{Relax}{$s$, $v$, $u$} \Comment{релаксация дуги $(u, v)$}
			\EndIf
		\EndFor
  \EndWhile
  \end{algorithmic}
\end{algorithm}

## Алгоритм Беллмана-Форда

Алгоритм Беллмана-Форда \ref{alg:bellman-ford} находит кратчайшие пути во взвешенном графе,
не содержащем циклы с отрицательным суммарным весом, от одной вершины до всех остальных[@shaporev2006].

При этом алгоритм Беллмана-Форда позволяет определить наличие циклов
отрицательного веса, достижимых из начальной вершины.

_Сложность алгоритма_: $𝒪(p⋅q)$, где $p$ — количество вершин, $q$ — количество ребер.

\begin{algorithm}
  \caption{Беллмана–Форда}\label{alg:bellman-ford}
  \begin{algorithmic}
  \Require
  	взвешенный орграф $G(V, E)$,
  	матрица весов $W$ : \Array{1..$p$, 1..$p$}{\Real},
		источник $s$.
  \Ensure
  	вектор $T$ : \Array{1..$p$}{\Real} длин кратчайших путей от источника,\\
  	вектор $Π$ : \Array{1..$p$}{0..$p$} самих путей.
  \State \Call{Init}{$s$} \Comment{инициализация}
	\For{$i := 1, p − 1$}
	\ForAll{$(u, v) ∈ E$}
	\State \Call{Relax}{$s$, $v$, $u$}
	\EndFor
	\EndFor
	\ForAll{$(u, v) ∈ E$} \Comment{проверка на отрицательные контуры}
	\If{$T [v] > T [u] + W [u, v]$}
	\Stop \Comment{найден контур отрицательного веса}
	\EndIf
	\EndFor
  \end{algorithmic}
\end{algorithm}

## Алгоритм Флойда-Уоршелла

Алгоритм Флойда-Уоршелла \ref{alg:floydworshall} находит кратчайшие пути между всеми парами 
вершин (узлов) в (ор)графе. Веса ребер могут быть как положительными, так и 
отрицательными.

Для нахождения кратчайших путей между всеми вершинами графа 
используется восходящее динамическое программирование, то есть все подзадачи, которые 
впоследсвии понадобятся для решения исходной задачи, просчитываются заранее, а затем
используются[@novikov2008].

<!-- про циклы отрицательного суммарного веса -->
Алгоритм не всегда выдаёт
решение, поскольку оно не всегда определено.
Дополнительный цикл по $j$ служит
для прекращения работы в случае обнаружения в орграфе контура с отрицательным
весом.

_Идея алгоритма_ — разбиение процесса поиска кратчайших путей на фазы.

_Сложность алгоритма_: $𝒪(p^3)$.

\begin{algorithm}
  \caption{Флойда-Уоршалла поиска всех кратчайших путей}
  \label{alg:floydworshall}
  \begin{algorithmic}
  \Require
  	матрица $W$ : \Array{1..$p$, 1..$p$}{\Real}  длин дуг.
  \Ensure матрица $T$: \Array{1..$p$, 1..$p$}{\Real} длин путей и\\
          матрица $Π$: \Array{1..$p$, 1..$p$}{0..$p$} самих путей.
\For{$i := 1, p$} \Comment{инициализация}
\For{$j := 1, p$}
\State $T [i, j] := W [i, j]$
\If{$W[i, j] = ∞$}
\State $Π[i, j] := 0$ \Comment{нет дуги из $i$ в $j$}
\Else
\State $Π[i, j] := i$ \Comment{есть дуга из $i$ в $j$}
\EndIf
\EndFor
\EndFor
\For{$i := 1, p$}
\For{$j := 1, p$}
\For{$k := 1, p$}
\If{$\begin{cases} i ≠ j ∧ T [j, i] ≠ ∞ \\ i ≠ k ∧ T [i, k] ≠ ∞ \\ T [j, k] = ∞ ∨ T [j, k] > T [j, i] + T [i, k] \end{cases}$}
\State $T [j, k] := T [j, i] + T [i, k]$ \Comment{запомнить длину нового пути}
\State $Π[j, k] := i$ \Comment{и сам путь}
\EndIf
\EndFor
\EndFor
\For{$j := 1, p$}
\If{$T [j, j] < 0$}
\Stop \Comment{Узел $j$ входит в отрицательный контур}
\EndIf
\EndFor
\EndFor
\end{algorithmic}
\end{algorithm}

## Максимальный поток в сети

Пусть $G(V,E,c)$ --- сеть, $s$ и $t$ --- cоответственно, источник и сток сети.
Дуги сети нагружены неотрицательными вещественными числами, $c:\ E → ℝ_+$.
Если $u$ и $v$ --- узлы сети, то число $c(u,v)$ --- называется _пропускной способностью_ дуги $(u,v)$. 

_Дивергенцией функции_ $f$ в узле $v$ называется число $\div(f, v)$, которое определяется следующим образом:

$$ \div(f,u) ≝ ∑_{v|(u,v) ∈ E} f(u,v) \quad- ∑_{v|(u,v) ∈ E} f(v,u)
$$

Функция $f: E → ℝ$ называется _потоком_ в сети $G$, если:

1. $∀ (u,v) ∈ E (0 ⩽ f(u,v) ⩽ c(u,v))$,
		то есть поток через дугу неотрицателен и не превосходит пропускной способности дуги.
2. $∀ u ∈ V ⧵ \{s,t\} (\div(f,u)=0)$, то есть дивергенция потока равна нулю во всех узлах,
		кроме источника и стока.

_Величина потока в сети_ $G$ --- сумма всех потоков,
выходящих из истока, то есть[@novikov2008]
$$ w(f) = \div(f,s).
$$

Рассмотрим пару
вершин $u,v∈V$. Определим _остаточную пропускную способность_
$c_f(u,v)$ как
$$ c_f(u,v) = \begin{cases}
	c(u,v) - f(u,v), & \text{если }(u,v)∈E,\\
	f(v,u),          & \text{если }(v,u)∈E,\\
	0                & \text{иначе.}
\end{cases}
$$

## Алгоритм Форда-Фалкерсона

_Теорема Форда-Фалкерсона_ Максимальный поток в сети равен минимальной пропускной способности разреза, то есть существует поток $f^*$ такой, что 
$$ w(f^*) = \max_f w(f) = \min_P C(P).
$$

На основе данной теоремы реализуется алгоритм Форда-Фалкерсона для определения максимального потока в сети,
заданной матрицей пропускных способностей дуг.

Алгоритм Форда-Фалкерсона решает задачу нахождения максимального потока в транспортной сети[@novikov2008].

Приведенная реализация \ref{alg:ffulk} метода Форда-Фалкерсона вычисляет максимальный поток в транспортной сети
$G(V, E)$ путем обновления
атрибута потока $(u,v).f$ каждого ребра $(u,v)∈E$.
Если $(u,v)∉E$, неявно предполагается, что $(u,v).f=0$.

\begin{algorithm}
\caption{Форда-Фалкерсона нахождения максимального потока в сети}
\label{alg:ffulk}
\begin{algorithmic}
\Require Граф $G(V,E)$,
источник $s$ и сток $t$ сети.

Пропускные способности $c(u,v)$, $c(u,v) = 0$ если $(u,v)∉E$.
\Ensure 
\For{$(u,v)∈E$}
	\State $(u,v).f = 0$
\EndFor
\While{существует путь $p$ из $s$ в $t$ в остаточной сети $G_f$}
	\State $c_f(p) := \min \{ c_f(u,v) : (u,v)∈p \}$ \Comment{$c_f(p)$ --- локальная переменная цикла}
	\For{$(u,v) ∈ p$}
		\If{$(u,v)∈E$}
			 $(u,v).f := (u,v).f + c_f(p)$
		\Else
			 $\ (v,u).f := (v,u).f - c_f(p)$
		\EndIf
	\EndFor
\EndWhile
\end{algorithmic}
\end{algorithm}

Можно улучшить временную границу алгоритма \ref{alg:ffulk}, если реализовать вычисление увеличивающего пути $p$ в строке __while__ как поиск в ширину,
т.е. если в качестве увеличивающего пути выбрать кратчайший путь из $s$ в $t$
в остаточной сети, где каждое ребро имеет единичную длину (вес). Такая реализация метода Форда-Фалкерсона называется _алгоритмом Эдмондса-Карпа_
(Edmonds-Karp algorithm)[@cormen2013].

_Сложность алгоритма_: $𝒪(p⋅q^2)$.

## Вычисление потока минимальной стоимости

Рассмотрим задачу определения потока заданной величины $θ$ от $s$ к $t$ в сети
$G(V,E,c,d)$, в которой каждая дуга $(u,v) ∈ E$ характеризуется не только пропускной способностью
$c(u,v)$, но и неотрицательной стоимостью $d(u,v)$ пересылки единичного потока из
$i$ в $j$ вдоль дуги $(u,v)$. $d:\ E → ℝ_+$.

Если $θ>f_{\max}$, где $f_{\max}$ --- величина максимального потока в сети $G$ от $s$ к $t$,
то решения нет.
Если же $θ⩽f_{\max}$, то может быть определено несколько различных потоков величины
$θ$ от $s$ к $t$.

Математическая модель задачи ---
минимизировать целевую функцию выбором потока $f$:

$$ ∑_{(u,v) ∈ E} d(u,v) ⋅ f(u,v) → \min_{f},
$$

где $d(u,v)$ --- вес дуги $(u,v)$, $f(u,v)$ --- величина потока вдоль дуги $(u,v)$[@shaporev2006].

## Задача определения максимального потока в сети с несколькими истоками и несколькими стоками

В задаче о максимальном потоке может быть несколько истоков и стоков. Например,
$m$ истоков $\{ s_1, s_2, \dotsc, s_m\}$ и
$n$ стоков $\{t_1,t_2, \dotsc,t_n\}$.

Задача определения максимальном потока в сети с несколькими истоками
и несколькими стоками сводится к обычной задаче о максимальном потоке.
Для этого в сеть добавляется _фиктивный исток_ (supersource) $s$
и ориентированные ребра $(s, s_i)$ с пропускной способностью
$$ c(s,s_i)=∞, \qquad i = 1,\dotsc,m.
$$
Точно так же создается _фиктивный сток_ (supresink) $t$ и добавляются ориентированные ребра $(t_i, t)$, обладающие
$$ c(t_i , t) = ∞, \qquad i=1,\dotsc,n.
$$

Единственный исток $s$ обеспечивает поток любой требуемой величины к истокам $s_i$, а единственный сток $t$ аналогичным образом потребляет поток любой желаемой величины от множественных стоков $t_i$[@cormen2013].

## Минимальный остов

_Остовным деревом_ или _остовом_ графа $G(V, E)$ называется связный подграф без циклов, содержащий все вершины исходного графа.
Любое остовное дерево в графе с $|V| = n$ вершинами
содержит ровно $n-1$ ребро.

_Минимальное остовное дерево_ — это остовное дерево,
сумма весов ребер которого минимальна.

_Задача о минимальном остове_: во взвешенном связном графе найти остов минимального веса, то есть остов, суммарный вес ребер которого является минимальным[@novikov2008].

## Алгоритм Прима

Алгоритм Прима --- алгоритм построения минимального остовного дерева взвешенного связного неориентированного графа.

В данном алгоритме кратчайший остов порождается в процессе разрастания одного дерева, к которому присоединяются ближайшие одиночные вершины.
При этом для каждой вершины $v$, кроме начальной,
используются две пометки: $α[v]$ — это ближайшая
к $v$ вершина, уже включённая в остов, а $β[v]$ — это длина ребра, соединяющего $v$ с остовом.
Если вершину $v$ ещё нельзя соединить с остовом одним ребром, то
$α[v] := 0$, $β[v] := ∞$.

На выходе мы получаем множество ребер, которые лежат в минимальном остовном дереве[@novikov2008].

\begin{algorithm}
\caption{Прима, нахождения остовного дерева минимальной стоимости}\label{alg:prim}
\begin{algorithmic}
\Require граф $G(V, E)$, заданный матрицей длин рёбер $C$.
\Ensure множество $T$ рёбер кратчайшего остова.
\State \Select $u ∈ V$ \Comment{выбираем произвольную вершину}
\State $S :=\{u\}$ \Comment{$S$ — множество вершин, включённых в кратчайший остов}
\State $T := ∅$ \Comment{$T$ — множество рёбер, включённых в кратчайший остов}
\For{$v ∈ V − u$}
\If{$v ∈ Γ(u)$}
\State $α[v] := u$ \Comment{$u$ — ближайшая вершина остова}
\State $β[v] := C[u, v]$ \Comment{$C[u, v]$ — длина соответствующего ребра}
\Else
\State $α[v] := 0$ \Comment{ближайшая вершина остова неизвестна}
\State $β[v] := ∞$ \Comment{и расстояние также неизвестно}
\EndIf
\EndFor
\For{$i:=1,p−1$}
\State $x := ∞$ \Comment{начальное значение для поиска ближайшей вершины}
\For{$v ∈ V ⧵ S$}
\If{$β[v] < x$}
\State $w := v$ \Comment{нашли более близкую вершину}
\State $x := β[v]$ \Comment{и расстояние до неё}
\EndIf
\EndFor
\State $S := S + w$ \Comment{добавляем найденную вершину в остов}
\State $T := T + (α[w], w)$ \Comment{добавляем найденное ребро в остов}
\For{$v ∈ Γ(w)$}
\If{$v ∉ S ∧ β[v] > C[v, w]$}
\State $α[v] := w$ \Comment{изменяем ближайшую вершину остова}
\State $β[v] := C[v, w]$ \Comment{и длину ведущего к ней ребра}
\EndIf
\EndFor
\EndFor
\end{algorithmic}
\end{algorithm}

_Сложность алгоритма_: $𝒪(p^2)$.

## Алгоритм Краскала

Алгоритм Краскала --- жадный алгоритм построения минимального остовного дерева
взвешенного связного неориентированного графа.

Алгоритм \ref{alg:kruskal} состоит из двух фаз.

1. На подготовительной фазе все дуги удаляются из дерева и упорядочиваются по возрастанию их весов.
		В графе остаются только вершины, каждая из которых образует отдельную компоненту связности.

2. Во второй фазе дуги перебираются в порядке возрастания веса.
		Если начало и конец очередной дуги принадлежат одной и той же компоненте связности, дуга игнорируется.
		Если же они лежат в разных компонентах связности. дуга добавляется к графу,
		а эти две компоненты связности объединяются в одну.
		Если число компонент связности дойдет до 1, цикл прерывается.

_Сложность алгоритма_: $𝒪(q \log p)$, где
$p$ --- количество вершин,
$q$ --- количество ребер графа.

\begin{algorithm}
\caption{Краскала, нахождения остовного дерева минимальной стоимости}
\label{alg:kruskal}
\begin{algorithmic}
  \Require
  	список $E$ рёбер графа $G$ с длинами,
  	упорядоченный в порядке возрастания длин.
  \Ensure множество $T$ рёбер кратчайшего остова.
\State $T :=∅$
\State $k := 1$ \Comment{номер рассматриваемого ребра}
\For{$i := 1, p − 1$}
\While{$z(T + E[k]) > 0$}
\State $k := k + 1$ \Comment{пропустить это ребро}
\EndWhile
\State $T := T + E[k]$ \Comment{добавить это ребро в SST}
\State $k := k + 1$ \Comment{и исключить его из рассмотрения}
\EndFor
\end{algorithmic}
\end{algorithm}
<!-- SST — Shortest Spanning Tree — стандартное обозначение для кратчайшего остова. -->

## Матричная теорема Кирхгофа

_Матрица Кирхгофа_ --- матрица
$B(G) = (β_{ij})_{p×p} = \diag\{\deg v_i\}-A(G)$,
где $p$ --- количество вершин графа.
$A(G) = (α_{ij})_{p×p} = (v_i ∈ Γ(v_j))$ --- матрица смежности.
$$ β_{ij} = \begin{cases}
-1,&  \text{если $v_i$ смежна с $v_j$;}\\
0,  &\text{если $i ≠ j$, $v_i$ не смежна с $v_j$;}\\
\deg v_i,&  \text{если $i = j$.}
\end{cases}
$$

### Свойства матрицы Кирхгофа

1. Суммы элементов в каждой строке и каждом столбце матрице равны 0.
2. Алгебраические дополнения всех элементов матрицы равны между собой.
3. Определитель матрицы Кирхгофа равен нулю.

_Матричная теорема Кирхгофа_

Число остовных деревьев в связном графе $G$ порядка $p ⩾ 2$ равно
алгебраическому дополнению $A_{ij}$ любого элемента матрицы Кирхгофа $B(G)$[@shaporev2006].
$$ A_{ij} = (-1)^{i+j} |M_{ij}|,
$$
где $|M_{ij}|$ --- минор, полученный из матрицы $B$ вычеркиванием $i$-й строки и $j$-го столбца.

## Код Прюфера

_Код Прюфера_ --- это способ взаимно однозначного кодирования помеченных деревьев с $p$ вершинами с помощью последовательности $p-2$ целых чисел в отрезке $[1,p]$. То есть, код Прюфера --- это биекция между всеми остовными деревьями полного графа и числовыми последовательностями.

\begin{algorithm}
\caption{Построение кода Прюфера свободного дерева}
\label{alg:pruefer-encode}
\begin{algorithmic}
\Require Дерево $T(V, E)$ в любом представлении, вершины дерева пронумерованы
числами $1..p$ произвольным образом.
\Ensure Массив $A$: \Array{1..$p − 1$}{1..$p$}
— код Прюфера дерева $T$.
\For{$i := 1, p−1$}
\State $v := \min \{k ∈ V | d(k) = 1\}$ \Comment{выбираем висячую вершину $v$}
\State $A[i] := Γ(v)$ \Comment{заносим в код номер единственной вершины, смежной с $v$}
\State $V := V − v$ \Comment{удаляем вершину $v$ из дерева}
\EndFor
\end{algorithmic}
\end{algorithm}

_Сложность алгоритма_ \ref{alg:pruefer-encode}: $𝒪(p \log p)$, если поиск минимума осуществляется за $𝒪(\log p)$.

Восстанавление закодированного по коду Прюфера дерева --- алгоритм \ref{alg:pruefer-decode}.

\begin{algorithm}
\caption{Распаковка кода Прюфера свободного дерева}
\label{alg:pruefer-decode}
\begin{algorithmic}
\Require Массив $A$: \Array{1..$p − 1$}{1..$p$}
— код Прюфера дерева $T$.
\Ensure Дерево $T(V, E)$, заданное множеством рёбер $E$, вершины
пронумерованы числами $1..p$.
\State $E : = ∅$ \Comment{вначале множество рёбер пусто}
\State $B : = 1..p$ \Comment{множество неиспользованных номеров вершин}
\For{$i := 1,p − 1$}
\State \Comment{выбираем вершину $v$ — неиспользованную вершину с наименьшим}
\State \Comment{номером, который не встречается в остатке кода Прюфера}
\State $v : = \min \left\{k ∈ B \middle| ∀ j ⩾ i (k ≠ A[j])\right\}$
\State $E : = E + (v, A[i])$ \Comment{добавляем ребро $(v, A[i])$}
\State $B : = B − v$ \Comment{удаляем вершину $v$ из списка неиспользованных}
\EndFor
\end{algorithmic}
\end{algorithm}

_Сложность алгоритма_ \ref{alg:pruefer-decode}: $𝒪(p \log p)$, если поиск минимума осуществляется за $𝒪(\log p)$.

## Эйлеров граф

Если связный граф имеет цикл (не обязательно простой),
содержащий все рёбра графа (каждое --- по одному разу),
то такой цикл называется _эйлеровым_ циклом,
а граф называется _эйлеровым_ графом.
Эйлеров цикл содержит все вершины графа.

_Теорема_ Если граф $G$ связен и нетривиален,
то $G$ — эйлеров граф $⟺$ каждая вершина $G$ имеет чётную степень[@novikov2008].

\begin{algorithm}
\caption{построения эйлерова цикла}
\label{alg:euler_cyc}
\begin{algorithmic}
\Require эйлеров граф $G(V, E)$, заданный списками смежности ($Γ[v]$ --- список вершин,
смежных с вершиной $v$).
\Ensure последовательность вершин эйлерова цикла.
\State $S := ∅$ \Comment{стек для хранения вершин}
\State \Select $v ∈ V$ \Comment{произвольная вершина}
\State $v → S$ \Comment{положить $v$ в стек $S$}
\While{$S ≠ ∅$}
\State $v := \Top S$ \Comment{$v$ — верхний элемент стека}
\If{$Γ[v] = ∅$}
\State $v ← S$; \Yield $v$ \Comment{очередная вершина эйлерова цикла}
\Else
\State \Select $u ∈ Γ[v]$ \Comment{взять первую вершину из списка смежности}
\State $u → S$ \Comment{положить u в стек}
\State $Γ[v] := Γ[v] − u$; $Γ[u] := Γ[u] − v$ \Comment{удалить ребро $(v, u)$}
\EndIf
\EndWhile
\end{algorithmic}
\end{algorithm}

_Сложность алгоритма_ \ref{alg:euler_cyc}: $𝒪(q)$.

## Гамильтонов граф

Если граф имеет простой цикл, содержащий все вершины графа (по одному разу), то такой цикл называется _гамильтоновым_ циклом, а граф называется _гамильтоновым_ графом.

Гамильтонов цикл не обязательно содержит все ребра графа. Гамильтоновым может быть только связный граф.

_Достаточное условие гамильтоновости графа_ (условие Дирака):

Если $p(G)⩾3$ и $δ(G) ⩾ \frac p 2$, то граф $G$ является гамильтоновым[@novikov2008].

## Задача коммивояжёра

Задача коммивояжёра --- задача отыскания кратчайшего гамильтонова цикла в нагруженном полном графе.[@novikov2008]

Гамильтонов цикл --- с комбинаторной точки 
зрения --- перестановка вершин графа.
При этом в качестве начальной вершины цикла можно выбрать любую,
так что можно рассматривать перестановки с фиксированным первым элементом.

Пусть дана матрица стоимостей $C = (c_{ij})$, где $c_{ij}$ --- стоимость перехода из вершины
$i$ в $j$ ($i,j=1,\dotsc,p$). Обозначим $1,v_1, v_2,\dotsc, v_{n-1}, 1$ --- номера вершин, записанные в порядке их обхода.
То есть $v_k$ --- номер вершины, посещаемой на $k$-м шаге, $k =0,\dotsc, p$, $v_0=v_p=1$.
Тогда пройденное расстояние можно представить в виде _целевой функции_:

$$ ∑_{k=0}^{n-1} w(v_k, v_{k+1}) → \min_{(v_1,\dotsc, v_{n-1})},
$$
где $(v_1,\dotsc, v_{n-1})$ --- перестановка чисел $2..p$.
Таким образом задача коммивояжера состоит в поиске перестановки целых чисел от 2 до $p$, при которой целевая функция минимальна.

_Простая схема поиска гамильтонова цикла:_

1. последовательно рассмотреть все эти перестановки,
2. проверить для каждой из них, представляет ли она цикл в данном графе.

Такой способ действий уже при не очень большом числе вершин становится практически неосуществимым ввиду быстрого роста числа перестановок — имеется $(p-1)!$ перестановок из $p$ элементов с фиксированным первым элементом.[@alexeev2012]

### Алгоритм поиска гамильтоновых циклов

Более рациональный подход (алгоритм \ref{alg:ham_cyc}) состоит в рассмотрении всевозможных
простых путей, начинающихся в произвольно выбранной стартовой 
вершине $a$, до тех пор, пока не будет обнаружен гамильтонов цикл или все
возможные пути не будут исследованы. Так же производится
перебор перестановок, но значительно сокращенный --- если, например,
вершина $b$ не смежна с вершиной $a$, то все $(p-2)!$ перестановок, у 
которых на первом месте стоит $a$, а на втором $b$,
не рассматриваются[@alexeev2012].

\begin{algorithm}
\caption{поиска гамильтоновых циклов}
\label{alg:ham_cyc}
\begin{algorithmic}
\Require граф $G(V,E)$ заданный списками смежности: $Γ[x]$ --- список вершин смежных с $x$.
\Ensure последовательность гамильтоновых циклов $S$
\State \Select $a∈V$ \Comment{выбрать произвольно вершину $a$}
\State $S = \{a\}$
\State $N[a] := Γ[a]$
\While{$S≠∅$}
	\State $x := \Top S$
	\If{$N[x]≠∅$}
		\State \Select $y∈N[x]$
		\State $N[x] := N[x] - y$
		\If{вершина $y$ не находится в $S$}
			\State $y ⇒ S$ \Comment{поместить $y$ в $S$}
			\State $N[y]:=Γ[y]$
			\If {$S$ содержит все вершины $∧$ $y$ смежна с $a$}	
				\State \Yield $S$
			\EndIf
		\EndIf
	\Else \ удалить вершину $x$ из $S$
	\EndIf
\EndWhile
\end{algorithmic}
\end{algorithm}

<!--
Проблему коммивояжёра можно представить в виде модели на графе, то есть, используя вершины и ребра между ними. Таким образом, вершины графа соответствуют городам, а рёбра $\left(i,j\right)$ между вершинами$i$ и $j$ — пути сообщения между этими городами. Каждому ребру $\left(i,j\right)$ можно сопоставить критерий выгодности маршрута $c_{ij}⩾0$, который можно рассматривать как, расстояние между городами, время или стоимость поездки.
-->

<!--
# Существование маршрута

_Теорема_

Для определения количества маршрутов, состоящих из k рёбер, необходимо возвести в k-ую степень матрицу смежности вершин. Тогда элемент p_{ij} полученной матрицы даст количество маршрутов длины k из v_i в v_j .

_Следствие_

В графе G, заданном матрицей смежности P размера n × n \, (|V| = n), \, ∃ маршрут vi → vj ⇔ элемент p_ij матрицы P + P^2+P^3 + ... + P^{n−1} не равен нулю.
-->

# Особенности реализации

## Структуры данных и константы

Ориентированный взвешенный граф представлен в программе матрицей весов (дуг):

```cpp
template<typename T=int>
using adjacency_matrix = std::vector<std::vector<T>>;
```

$$ M[i][j] = \begin{cases}
	0, & \text{если вершины }i, j\text{ не смежны},\\
	ω, & \text{если вес ребра }ij = ω.\quad ω ∈ ℤ⧵\{0\}
\end{cases}
$$
Таким образом, нулевой вес в матрице однозначно говорит об отсутствии дуги.

Вершина представлена своим номером --- беззнаковое целое:

```cpp
using Vertex = size_t;
```

Взвешенное ребро (дуга) представлено в программе структурой `edge_t`:

```{.cpp include=../L1/graphs.h snippet=edge_t dedent=4}
```

Пути в графе представлены массивом вершин:

```cpp
using path_t = std::vector<Vertex>;
```

Путь вместе со своим суммарным весом представлен структурой `costed_path_t`:

```{.cpp include=../L1/graphs.h snippet=costed_path_t dedent=4}
```

Поток в сети представлен структурой `flow_graph_t`:

```{.cpp include=../L1/graphs.h snippet=flow_graph_t dedent=4}
```

Код Прюфера для дерева из $p$ вершин представлен в программе парой,
первый ее элемент --- массив из $p-2$ номеров вершин,
второй --- массив весов соответствующих ребер ($p-1$ число).

```cpp
std::pair<std::vector<Vertex>, std::vector<int>>
```

В программе определены следующие константы:

```cpp
// бесконечный вес ребра
constexpr auto INF = INT32_MAX;
// номер несуществующей вершины
constexpr Vertex NO_VERTEX = -1u;
```

Значение `NO_VERTEX` используется в матрице (и векторе) предшествования для обозначения, что соответствующий путь не существует.
См.~подробнее [Алгоритм Дейкстры], [Алгоритм Флойда-Уоршелла].

## Генерация графа. Построение маршрута

### Генерация случайной величины с распределением Пойа 1

#### Функция

`template <class IntType = int>
std::discrete_distribution<IntType>
polya_1(IntType black_n, IntType red_n, IntType c, IntType size);`{.cpp}

#### Вход функции

- `black_n` --- параметр распределения $b$
- `red_n`  --- параметр распределения $r$
- `c` --- параметр распределения $c$
- `size` --- параметр распределения $n$ --- количество различных значений

#### Выход функции

представитель шаблона `std::discrete_distribution`, хранящий в себе соответствующую таблицу распределения вероятностей.

#### Описание работы функции

Алгоритм \ref{alg:poja} реализован следующим образом: 

1. Функция `polya_1` заполняет таблицу вероятностей для значений из диапазона $0 ⩽ x < n$,
2. Функция [`std::discrete_distribution::operator()`](https://en.cppreference.com/w/cpp/numeric/random/discrete_distribution/operator()) выдает случайное число с заданным распределением вероятностей.

Чтобы убедиться в том, что с помощью функции `polya_1` генерируются случайные числа с необходимым распределением, были построены гистограммы для 4 различных наборов параметров. Ниже представлен код, выдающий исходные данные для построения гистограмм. Сами гистограммы изображены на рис. \ref{fig:real_hystograms}.

```{.cpp include=../L1/polya_dist.cpp snippet=polya_1_histograms}
```

#### Исходный код

```{.cpp include=../L1/polya_dist.h snippet=polya_1}
```

Пример использования:

```cpp
auto dis = polya_1<>(20, 20, 1, 5);
std::random_device rd;
std::mt19937 gen(rd());
std::cout << "random - " << dis(gen);
```

### Генерация графа

Отсутствие циклов гарантируется тем, что заполняются только элементы матрицы выше главной диагонали,
т. о. получается верхнетреугольная матрица.

Связность гарантируется тем, что генерируемые степени вершин
$\deg^+ v > 0$, кроме одной вершины.

Веса ребер также подчиняются тому же распределению, но с другими коэффициентами.

#### Функция

`adjacency_matrix<> generate(size_t nVertices, std::mt19937& gen);`{.cpp}

#### Вход функции

Количество вершин `nVertices`, генератор случайных чисел `gen`.

#### Выход функции

Матрица весов, определяющая граф.

#### Описание работы функции

1. Функция `out_degrees` формирует массив степеней (выхода) вершин орграфа, подчиняющихся заданному распределению. Причем они отсортированы в порядке убывания.
2. Функция `from_degrees` заполняет матрицу весовю графа. Количество ненулевых элементов в строке $i$ равно `vertex_degrees[i]`. Матрица по построению верхнетреугольная (нули на главной диагонали и под ней).

#### Исходный код

```{.cpp include=../L1/graphs.cpp snippet=generate}
```

### Метод Шимбелла

#### Функция

`adjacency_matrix<> min_path_lengths(const adjacency_matrix<>& that, size_t path_length);`{.cpp}

`adjacency_matrix<> max_path_lengths(const adjacency_matrix<>& that, size_t path_length);`{.cpp}

#### Вход функции

На вход обеим функциям подается матрица весов `that` и длина пути --- количество ребер `path_length`.

#### Выход функции

На выходе --- матрица минимальных (максимальных) расстояний между вершинами графа.

#### Описание работы функции

В основном соответствует описанию п. \ref{shim_math}.

Операции с матрицами в данной реализации параметризованы бинарной операцией `extrem`, играющей роль скалярного сложения в методе Шимбелла.

Возведение матрицы в степень выполняется последовательным умножением.
Умножение матриц производится тривиальным алгоритмом (по определению).

#### Исходный код

```{.cpp include=../L1/graphs.cpp snippet=shimbell}
```

### Поиск количества маршрутов между вершинами

Для данной задачи определена структура (фунуциональный объект)
`count_paths`:

```{.cpp include=../L1/graphs.h snippet=count_paths dedent=4}
```

Интерес представляет в первую очередь оператор `()` этой структуры.

#### Функция

`size_t count_paths::operator()(Vertex v);`{.cpp}

#### Вход функции

Матрица смежности `graph`, начальная вершина `start` (передаются в конструктор), конечная вершина `v`.

#### Выход функции

Количество различных путей из начальной вершины в конечную.

#### Описание работы функции

<!--
Акулич И.Л. Глава 4. Задачи динамического программирования // Математическое программирование в примерах и задачах. — М.: Высшая школа, 1986. — 319 с. — ISBN 5-06-002663-9 (там этого нет :( )

src: neerc.ifmo.ru/wiki/index.php?title=Задача_о_числе_путей_в_ациклическом_графе
-->

Искомое количество находится методом динамического программирования.

Пусть $s$ — стартовая вершина (`start`), а $t$ — конечная, для нее и посчитаем ответ. Будем поддерживать массив $d$, где $d[v]$ — число путей из вершины $s$ до вершины $v$ и массив $w$ (`visited`), где $w[v] = \textit{true}$, если ответ для вершины $v$ уже посчитан, и $w[v] = \textit{false}$ в противном случае. Изначально $w[i] = \textit{false}$ для всех вершин $i$, кроме $s$, а $d[s] = 1$.

Данная функция --- рекурсивная функция с запоминанием. Так, значения массива $d$ будут вычисляться по мере необходимости и не будут считаться лишний раз.

_Сложность алгоритма_: $𝒪(p+q)$.

#### Исходный код

```{.cpp include=../L1/graphs.cpp snippet=count_paths_op}
```

## Нахождение кратчайшего пути

### Алгоритм Дейкстры

#### Функция

`dijkstra_result_t min_path_distances_dijkstra(const adjacency_matrix<>& g, Vertex start_vertex);`{.cpp}

#### Вход функции

Матрица весов `g`, начальная вершина `start_vertex`.

#### Выход функции

Структура `dijkstra_result_t`.

```{.cpp include=../L1/graphs.h snippet=dijkstra_result_t dedent=4}
```

#### Описание работы функции

Функция реализует алгоритм Дейкстры \ref{alg:dijkstra}. Находит кратчайшие пути во взвешенном графе от одной вершины до всех остальных, если длины дуг неотрицательны.

1. Начальная вершина помечается посещенной и помещается в очередь.
2. Пока очередь не пуста,
    1. Из нее извлекается непосещенная вершина `nearest_vertex`, текущее расстояние до которой наименьшее.
    2. Она помечается посещенной.
    3. Рассматриваются все ребра, исходящие из вершины `nearest_vertex`, и если текущее расстояние до конца этой вершины `distances[v]` можно улучшить пройдя через рассматриваемое ребро, то обновляется значение `distances[v]` и вершина добавляется в очередь.

Найденные значения `distances[v]` и есть искомые длины кратчайших путей из начальной вершины в `v`.

В качестве структуры, позволяющей вынимать (`pop`) минимальный элемент за $𝒪(\log p)$, используется [`std::priority_queue`](https://en.cppreference.com/w/cpp/container/priority_queue), реализующая бинарную кучу.

_Сложность алгоритма_: $𝒪\left((p+q)\log p\right)$.

#### Исходный код

```{.cpp include=../L1/graphs.cpp snippet=dijkstra}
```

### Алгоритм Беллмана-Форда

#### Функция

`dijkstra_result_t min_path_distances_bellman_ford(const adjacency_matrix<>& g, Vertex start_vertex);`{.cpp}

#### Вход функции

Матрица весов `g`, начальная вершина `start_vertex`.

#### Выход функции

Структура `dijkstra_result_t`.

#### Описание работы функции

Функция находит кратчайшие пути во взвешенном графе, реализуя алгоритм Беллмана-Форда \ref{alg:bellman-ford}.

1. На первом шаге расстояния от исходной вершины до всех остальных вершин (массив `distances`) принимаются равными бесконечности,
	 а расстояние до начальной вершины --- нулю: `distances[u] = 0`.
2. Вторым шагом вычисляются самые короткие расстояния. Следующие шаги нужно выполнять $p-1$ раз,
   где $p$ —-- число вершин в графе.
   
    Производится следующее действие для каждого ребра $uv$:
   
    Если `distances`[$v$] > `distances`[$u$] + вес ребра $uv$, то обновляется
    `distances`[$v$] = `distances`[$u$] + вес ребра $uv$

3. На третьем шаге сообщается, присутствует ли в графе цикл отрицательного веса. Для каждого ребра $uv$ необходимо выполнить следующее:
  	
  	Если `distances`[$v$] > `distances`[$u$] + вес ребра $uv$, то в графе присутствует цикл отрицательного веса.

Идея шага 3 заключается в том, что шаг 2 гарантирует кратчайшее расстояние, если граф не содержит цикла отрицательного веса. Если мы снова переберем все ребра и получим более короткий путь для любой из вершин, это будет сигналом присутствия цикла отрицательного веса.

Релаксация каждого ребра занимает константное количество действий. Всего ребер --- $q$, релаксация всех ребер производится $p$ раз. Таким образом, временная сложность алгоритма --- $𝒪(p⋅q)$.

#### Исходный код

```{.cpp include=../L1/graphs.cpp snippet=bellman_ford}
```

### Алгоритм Флойда-Уоршелла

Поиск кратчайших путей от каждой вершины к каждой.

#### Функция

`floyd_warshall_result_t min_path_distances_floyd_warshall(const adjacency_matrix<>& g);`{.cpp}

#### Вход функции

Матрица весов `g`.

#### Выход функции

Структура `floyd_warshall_result_t`.

```{.cpp include=../L1/graphs.h snippet=floyd_warshall_result_t dedent=4}
```

#### Описание работы функции

Функция следует алгоритму \ref{alg:floydworshall}.

Исходная матрица расстояний --- матрица весов, где все нули, кроме главной диагонали заменены символом $∞$.

В циклах по $i,j$ просматриваются все дуги графа. Если путь по дуге из вершины $i$ в вершину $j$ оказывается длиннее, чем путь из вершины $i$ в вершину $j$ через вершину $k$, новый путь записывается как наименьший.

Время работы алгоритма --- три вложенных цикла от 1 до $p$ --- $𝒪\left(p^3\right)$.

#### Исходный код

```{.cpp include=../L1/graphs.cpp snippet=floyd_warshall}
```

### Восстановление пути по вектору предшествования

#### Функция

`std::vector<Vertex> reconstruct_path(const std::vector<Vertex>& precedents, Vertex from, Vertex to);`{.cpp}

#### Вход функции

Вектор предшествования `precedents`, начальная вершина `from`, конечная --- `to`.

#### Выход функции

Массив `result` вершин в порядке из обхода по маршруту, представленного вектором предшествования.

#### Описание работы функции

Производится обход вектора предшествования:
последовательно, начиная с последней вершины `to` извлекается вершина, достигаемая кратчайшим путем из начальной вершины в текущую. Полученная последовательность обращается. Cм. [Вспомогательные процедуры].

#### Исходный код

```{.cpp include=../L1/graphs.cpp snippet=reconstruct_path}
```

## Нахожение максимального потоков и потока минимальной стоимости

### Определение истока и стока

#### Функция

`flow_graph_t add_supersource_supersink(const adjacency_matrix<>& capacity, const adjacency_matrix<>& cost);`{.cpp}

#### Вход функции

Матрица `capacity` пропускных способностей, матрица `cost` стоимостей.

#### Выход функции

Структура `flow_graph_t`, представляющая поток в графе, содержащем один исток и один сток.

#### Описание работы функции

Производится поиск вершин, удовлетворяющих условию истока (строка $i$ матрицы смежности нулевая) и условию стока (столбец $j$ матрицы смежности нулевой).

Если стоков (истоков) несколько,
то добавляется фиктивный сток (исток), соединенный дугой со всеми стоками (истоками).

Если сток (исток) единственный, то он и возвращается в поле `sink` (`source`) структуры `flow_graph_t`. Стоимости добавленных дуг принимаются нулевыми, а пропускные способности --- бесконечно большими.

#### Исходный код

```{.cpp include=../L1/graphs.cpp snippet=add_supersource_supersink}
```

### Алгоритм Форда-Фалкерсона

#### Функция

`flow_result_t max_flow_ford_fulkerson(const flow_graph_t& g);`{.cpp}

#### Вход функции

Структура `flow_graph_t`.

#### Выход функции

Структура `flow_result_t` --- матрица потока и суммарная его величина.

```{.cpp include=../L1/graphs.h snippet=flow_result_t dedent=4}
```

#### Описание работы функции

Находит максимальный поток по данной матрице пропускных способностей
(игнорируя стоимости).

#### Исходный код

```{.cpp include=../L1/graphs.cpp snippet=max_flow_ford_fulkerson}
```

### Поиск заданного потока минимальной стоимости

#### Функция

`min_cost_flow_result_t
min_cost_flow(const flow_graph_t& g, int desired_flow);`{.cpp}

#### Вход функции

Структура `flow_graph_t`, желаемая величина потока `desired_flow`. Она должна быть меньше или равна максимальной величины $f_{\max}$. В программе передается величина $\dfrac 2 3 f_{\max}$.

#### Выход функции

Структура `min_cost_flow_result_t`.

```{.cpp include=../L1/graphs.h snippet=min_cost_flow_result_t dedent=4}
```

#### Описание работы функции

Находит поток заданной величины с минимальной стоимостью в графе
(алгоритм \ref{alg:ffulk}).

1. Ищется минимальный по стоимости путь из истока в сток с помощью алгоритма Дейкстры (все дуги имеют неотрицательную стоимость).
2. Вычисляется максимальный поток по найденному пути.
3. Полученное значение прибавляется к значению потока каждой дуги найденного увеличивающего пути и отнимается от заданного значения потока.
4. Повторять, пока заданное значение потока не станет равным нулю.

#### Исходный код

```{.cpp include=../L1/graphs.cpp snippet=min_cost_flow}
```

## Поиск минимального остова

### Алгоритм Прима

#### Функция

`min_st_result_t kruskal_mst(const adjacency_matrix<>& g);`{.cpp}

#### Вход функции

Матрица смежности `g`.

#### Выход функции

Структура `min_st_result_t`. Остов минимальной стоимости представлен множеством дуг.

```{.cpp include=../L1/graphs.h snippet=min_st_result_t dedent=4}
```

#### Описание работы функции

Функция следует алгоритму \ref{alg:prim}.

1. Берётся произвольная вершина и находится ребро, инцидентное данной вершине и обладающее наименьшей стоимостью. Найденное ребро и соединяемые им две вершины образуют дерево.
2. Рассматриваются рёбра графа, один конец которых --- уже принадлежащая дереву вершина, а другой --- ещё не принадлежащая. Из этих рёбер выбирается ребро наименьшей стоимости.
3. Выбираемое на каждом шаге ребро присоединяется к дереву. Рост дерева происходит до тех пор, пока не будут исчерпаны все вершины исходного графа.

_Сложность алгоритма_: $𝒪(p^2)$.

#### Исходный код

```{.cpp include=../L1/graphs.cpp snippet=kruskal_mst}
```

### Алгоритм Краскала

#### Функция

`min_st_result_t prim_mst(const adjacency_matrix<>& g);`{.cpp}

#### Вход функции

Матрица смежности `g`.

#### Выход функции

Структура `min_st_result_t`.

#### Описание работы функции

Функция следует алгоритму \ref{alg:kruskal}.

Каждая вершина помещается в свое множество. 

Из всех рёбер, добавление которых к уже имеющемуся множеству не вызовет появление в нём цикла, выбирается ребро минимального веса. Затем мы проверяем принадлежат ли вершины ребра одному множеству. 

Если нет, то добавляем данное ребро в дерево, после добавления мы добавляем все вершины, которые принадлежали тому же множеству, что и вторая вершина ребра, в множество первой вершины.

Если же вершины уже принадлежат одному множеству, то переходим к следующему этапу цикла.

Подграф данного графа, содержащий все его вершины и найденное множество рёбер, является его остовным деревом минимального веса.

Подмножества множества вершин представлены структурой данных «Система непересекающихся множеств» (disjoint-set) вместе с эвристикой сжатия путей и эвристикой
Union-By-Height (ранг дерева --- его высота). Ее использование позволяет эффективно определить операции объединения множеств и поиска компоненты связности.

_Сложность алгоритма_: $𝒪(q \log p)$.

#### Исходный код

```{.cpp include=../L1/graphs.cpp snippet=prim_mst}
```

### Матричная теорема Кирхгофа

Подсчет количества остовных деревьев согласно теореме Кирхгофа.

#### Функция

`size_t spanning_trees_count(const adjacency_matrix<>& g);`{.cpp}

#### Вход функции

Матрица смежности `g`.

#### Выход функции

Количество остовных деревьев.

#### Описание работы функции

Матрица Кирхгофа строится по определению,
ее минор находится рекурсивно, по формуле разложения определителя по строке.

#### Исходный код

```{.cpp include=../L1/graphs.cpp snippet=spanning_trees_count}
```

## Код Прюфера

namespace pruefer

### Кодирование Прюфера

#### Функция

`std::pair<std::vector<Vertex>, std::vector<int>>
encode(const adjacency_matrix<>& g);`{.cpp}

#### Вход функции

Матрица весов `g` (ориентированного графа).

#### Выход функции

Код Прюфера минимального остова графа.

#### Описание работы функции

Функция реализует алгоритм \ref{alg:pruefer-encode}.

В цикле выбирается лист с наименьшим номером, в код Прюфера добавляется номер вершины, связанной с
этим листом. Процедура повторяется $p-1$ раз. Параллельно запоминаются ребра, связанные с текущим листом.

#### Исходный код

```{.cpp include=../L1/graphs.cpp snippet=encode}
```

### Декодирование Прюфера

#### Функция

`adjacency_matrix<>
decode(const std::vector<Vertex>& code, const std::vector<int>& weights);`{.cpp}

#### Вход функции

Код Прюфера: вектор номеров вершин и весов ребер. 

#### Выход функции

Матрица весов дерева, соответствующего коду. По построению матрица верхнетреугольная (орграф).

#### Описание работы функции

Функция реализует алгоритм \ref{alg:pruefer-decode}.

По построенному коду можно восстанавливается исходное дерево:

Берётся первый элемент кода Прюфера, и по всем вершинам дерева производится поиск вершины с наименьшим номером, не содержащейся в коде.

Найденная вершина и текущий элемент составляют ребро дерева. Вес ребра извлекается из массива весов.

#### Исходный код

```{.cpp include=../L1/graphs.cpp snippet=decode}
```

## Эйлеровы и Гамильтоновы графы

### Проверка графа на эйлеровость

#### Функция

`bool is_eulerian(const adjacency_matrix<>& g);`{.cpp}

#### Вход функции

Матрица смежности (ориентированного) графа `g`.

#### Выход функции

`true` если неориентированный граф, полученный из исходного забыванием направления дуг, --- эйлеров. Иначе `false`.

#### Описание работы функции

Непосредственно проверяется критерий эйлеровости. 

#### Исходный код

```{.cpp include=../L1/graphs.euler.cpp snippet=is_eulerian}
```

### Поиск Эйлерова цикла в эйлеровом графе

#### Функция

`path_t euler_cycle(adjacency_matrix<> g);`{.cpp}

#### Вход функции

Матрица смежности (ориентированного) графа `g`.

#### Выход функции

Эйлеров цикл неориентированного графа, полученного из исходного забыванием направления дуг.
Если такого цикла нет, то --- пустой массив.

#### Описание работы функции

Функция реализует алгоритм \ref{alg:euler_cyc}.

Начав с вершины $v$ (c наименьшей степенью), строим путь, удаляя рёбра и запоминая вершины
в стеке, до тех пор пока множество смежности очередной вершины не окажется
пустым, что означает, что путь удлинить нельзя.

#### Исходный код

```{.cpp include=../L1/graphs.euler.cpp snippet=euler_cycle}
```

### Проверка наличия гамильтонова цикла в неориентированном графе

#### Функция

`bool is_hamiltonian(adjacency_matrix<> g);`{.cpp}

#### Вход функции

Матрица смежности (ориентированного) графа `g`.

#### Выход функции

`true` если неориентированный граф, полученный из исходного забыванием направления дуг, --- гамильтонов. Иначе `false`.

#### Описание работы функции

Сначала выполняются проверки (достаточного) условия теоремы Дирака и необходимого условия. Если обе проверки несостоятельны, то производится поиск гамильтонова цикла.

#### Исходный код

```{.cpp include=../L1/graphs.hamilton.cpp snippet=is_hamiltonian}
```

### Задача коммивояжера

Для нахождения всех гамильтоновых циклов в графе определена структура `hamilton_cycles`,
которая реализует интерфейсы, необходимые для использования ее в конструкции [range-based for](https://en.cppreference.com/w/cpp/language/range-for) языка C++. Внутренняя структура `hamilton_cycles::iterator` удовлетворяет требованиям [LegacyInputIterator](https://en.cppreference.com/w/cpp/named_req/InputIterator), что, в частности, позволяет использовать ее в качестве аргумента некоторых функций стандартной библиотеки `<algorithm>`: `std::copy_n`, `std::for_each`.
Ключевое значение имеет функция `hamilton_cycles::iterator::find_next`, о ней см. ниже.

```{.cpp include=../L1/graphs.h snippet=hamilton_cycles dedent=4}
```

#### Функция

`costed_path_t hamilton_cycles::iterator::find_next`{.cpp}

#### Вход функции

Матрица смежности `g` неориентированного графа, начальная вершина цикла `start`, текущий отрезок пути `candidate`.

#### Выход функции

Следующий гамильтонов путь или пустой массив, если таковых больше нет.

#### Описание работы функции

Функция следует алгоритму \ref{alg:ham_cyc}.

На каждом шаге алгоритма имеется уже построенный
отрезок пути, он хранится в стеке `candidate`.
Для каждой вершины $x$, 
входящей в `candidate`, хранится множество $N[x]$ всех вершин, смежных с $x$, 
которые еще не рассматривались в качестве возможных продолжений пути из
вершины $x$.
Когда вершина $x$ добавляется к пути, множество $N(x)$ 
полагается равным его множеству смежности.
В дальнейшем рассмотренные вершины удаляются
из этого множества. Очередной шаг состоит в исследовании окрестности
последней вершины $x$ пути `candidate`. Если $N(x)$ не пусто и в $N(x)$ имеются 
вершины, не принадлежащие пути, то одна из таких вершин $y$ добавляется к
пути. В противном случае вершина $x$ исключается из стека.

Когда после
добавления к пути очередной вершины оказывается, что путь содержит
все вершины графа, остается проверить, смежны ли первая и последняя
вершины пути. Если это так, то возвращается очередной гамильтонов цикл[@alexeev2012].

#### Исходный код

```{.cpp include=../L1/graphs.hamilton.cpp snippet=hamilton_cycles_op}
```

### Модификация графа до эйлерова

#### Функция

`graph_change_t eulerize(const adjacency_matrix<>& g_original);`{.cpp}

#### Вход функции

Матрица смежности (ориентированного) графа `g_original`.

#### Выход функции

Структура `graph_change_t`, в которой `changed` --- матрица смежности графа, полученного ориентированием ребер эйлерова графа, который получен из исходного добавлением или удалением некоторых ребер.

```{.cpp include=../L1/graphs.h snippet=graph_change_t dedent=4}
```

#### Описание работы функции

Перед началом работы происходит забывание направлений дуг исходного графа. Получаем неориентированный граф.

Идея алгоритма следующая:

1. Найти вершины с нечётной степенью.
2. Выбрать паросочетание из них, желательно чтобы такого ребра ещё не было (т. е. минимальное паросочетание для двоичной матрицы смежности)
3. Для каждой пары вершин из паросочетания, добавить ребро если его не было, удалить если было
4. Если граф стал несвязным, то
5. Если компонент связности 3 или больше, соединить компоненты в цепь, выбрав в каждой из них по одной вершине, через которую она проходит.
6. Если компонент связности 2, то соединить 2 пары вершин из обеих.

Ориентирование ребер полученного графа происходит занулением весов дуг ниже главной диагонали матрицы смежности.

#### Исходный код

```{.cpp include=../L1/graphs.euler.cpp snippet=eulerize}
```

### Дополнение графа до гамильтонова

#### Функция

`graph_change_t hamiltonize(const adjacency_matrix<>& g);`{.cpp}

#### Вход функции

Матрица смежности (ориентированного) графа `g`.

#### Выход функции

Структура `graph_change_t`, в которой `changed` --- матрица смежности графа, полученного ориентированием ребер гамильтонова графа, который получен из исходного добавлением некоторых ребер.

#### Описание работы функции

Сперва все висячие вершины соединяются путем. Так не остается ни одной висячей вершины и выполняется очевидное необходимое условие гамильтоновости.

Если получившийся граф гамильтонов, функция завершается.

Затем производится попытка добавления сначала одной, затем двух, а потом трех ребер.
Если после добавления граф становится гамильтоновым, функция завершается, если нет, то ребро удаляется обратно и поиск продолжается.
Если же не нашлось тройки ребер, после добавление которых граф становится гамильтоновым, то функция завершает свою работу аварийно.

Попытка добавления всех возможных `level` ребер и проверка на гамильтоновость производится рекурсивной лямбда-функцией `iterate`, объявленной внутри функции `hamiltonize`. Рекурсия в этом случае возможна благодаря передаче ссылки на функциональный объект при вызове. Глубина рекурсии ограничивается передаваемым параметром `level`.

Ориентирование ребер графа производится из условия, что получившаяся матрица верхнетреугольная. 

#### Исходный код

```{.cpp include=../L1/graphs.hamilton.cpp snippet=hamiltonize}
```

# Результаты работы программы

Генерация случайного графа из 10 вершин продемонстрирована на рис. \ref{fig:gen}.

<!--
0	0	27	0	37	0	0	0	13	0
0	0	0	0	0	0	0	10	0	29
0	0	0	0	0	0	30	28	0	0
0	0	0	0	0	0	34	0	0	37
0	0	0	0	0	0	0	21	0	0
0	0	0	0	0	0	10	0	0	0
0	0	0	0	0	0	0	0	0	25
0	0	0	0	0	0	0	0	0	8
0	0	0	0	0	0	0	0	0	10
0	0	0	0	0	0	0	0	0	0 -->
: Матрица весов сгенерированного графа (ациклического, связного, ориентированного)

|  | $a$ | $b$ | $c$ | $d$ | $e$ | $f$ | $g$ | $h$ | $i$ | $j$
|--|--|--|--|--|--|--|--|--|--|--
| $a$ | — | — | 27 | — | 37 | — | — | — | 13 | —
| $b$ | — | — | — | — | — | — | — | 10 | — | 29
| $c$ | — | — | — | — | — | — | 30 | 28 | — | —
| $d$ | — | — | — | — | — | — | 34 | — | — | 37
| $e$ | — | — | — | — | — | — | — | 21 | — | —
| $f$ | — | — | — | — | — | — | 10 | — | — | —
| $g$ | — | — | — | — | — | — | — | — | — | 25
| $h$ | — | — | — | — | — | — | — | — | — | 8
| $i$ | — | — | — | — | — | — | — | — | — | 10
| $j$ | — | — | — | — | — | — | — | — | — | —

![Генерация графа, $p=10$\label{fig:gen}](img/1.1.png)

На рис. \ref{fig:shimb_min} представлена матрица Шимбелла минимальных путей для двух рёбер, на рис. \ref{fig:shimb_max} --- максимальных.

![Метод Шимбелла. Поиск минимального пути, матрица с положительными весами\label{fig:shimb_min}](img/1.2-max.png)

![Метод Шимбелла. Поиск максимального пути, матрица с положительными весами\label{fig:shimb_max}](img/1.2-min.png)

На рис. \ref{fig:path_count} показана проверка существования пути из вершины $a$ в вершину $h$.

![Существование и количество путей между вершинами $a$, $h$\label{fig:path_count}](img/1.3.png)

Следующие три рисунка (рис. \ref{fig:dij}-\ref{fig:f-w}) показывают работу алгоритмов по поиску
кратчайших путей в графе.

![Алгоритм Дейкстры \label{fig:dij}](img/2-беллман-форд.png)

![Алгоритм Беллмана-Форда](img/2-дейкстра.png)

![Алгоритм Флойда-Уоршелла \label{fig:f-w}](img/2-Флойд.png)

Рис. \ref{fig:gen_cost}-\ref{fig:mincost} показывают работу программы по поиску максимального потока по
алгоритму Форда-Фалкерсона, а также поиск потока минимальной
стоимости. В том числе и генерацию матрицы стоимостей.

![Генерация матрицы стоимостей\label{fig:gen_cost}](img/3-генер-стоимостей.png)

![Поиск и добавление (фиктивных) стока и истока\label{fig:super}](img/3-исток-сток.png)

![Алгоритм Форда-Фалкерсона\label{fig:ffalc}](img/3-ффалк.png)

![Поиск потока минимальной стоимости заданной величины\label{fig:mincost}](img/3-поток-мин-стоимости.png)

Поиск количества остовных деревьев по
матричной теореме Кирхгофа показан на рис. \ref{fig:kirghoff}.

![Подсчет числа остовных деревьев по матричной теореме Кирхгофа\label{fig:kirghoff}](img/4-кирхгоф.png)

На рис. \ref{fig:encode} представлено кодирование полученного минимального остова кодом Прюфера.

![Кодирование Прюфера\label{fig:encode}](img/4-код-Прюфера.png)

На рис. \ref{fig:decode} представлено декодирование кода Прюфера.

![Декодирование кода Прюфера\label{fig:decode}](img/4-декод-прюфер.png)

Следующие два рисунка (рис. \ref{fig:kruskal}-\ref{fig:prim})
показывают работу алгоритмов по поиску минимального остова в (неориентированном) графе.

![Алгоритм Краскала \label{fig:kruskal}](img/4-краскал.png)

![Алгоритм Прима \label{fig:prim}](img/4-прим.png)

На рис. \ref{fig:is_euler} показан результат работы алгоритма, который проверяет является ли граф эйлеровым.
На рис. \ref{fig:is_ham} --- гамильтоновым.

![Является ли эйлеровым\label{fig:is_euler}](img/5-эйлеров-ли.png)

![Является ли гамильтоновым\label{fig:is_ham}](img/5-гамильтонов-ли.png)

На рис. \ref{fig:eulerize} представлен результат модификации графа до эйлерова и найденный эйлеров цикл.

![Модификация графа до эйлерова\label{fig:eulerize}](img/5-эйлерова-модификация.png)

На рис. \ref{fig:hamiltonize} представлен результат модификации графа до гамильтонова и найденные гамильтоновы циклы.

![Модификация графа до гамильтонова\label{fig:hamiltonize}](img/5-гамильтонова-модификация.png)

<!-- test cases for eulerize:

# n = 10

0	0	1	0	0	0	0	0	1	1
0	0	0	0	0	0	1	0	0	1
0	0	0	0	1	0	0	0	1	0
0	0	0	0	1	0	1	0	0	0
0	0	0	0	0	0	0	0	1	1
0	0	0	0	0	0	1	0	0	1
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0	1	0
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0	0	0
+ah, -ci

# n = 4

△_
0	1	0	0
0	0	1	1
0	0	0	1
0	0	0	0
+ac +bc

# n = 4 

☒
0	1	1	1
0	0	1	1
0	0	0	1
0	0	0	0
-ab, cd

# n = 6

△_△
0	1	1	0	0	0
0	0	1	0	0	0
0	0	0	1	0	0
0	0	0	0	1	1
0	0	0	0	0	1
0	0	0	0	0	0
+ad -ac


# n = 4

0	1	1	0
0	0	0	1
0	0	0	1
0	0	0	0
-bc

# n = 9

0	1	1	0	0	0	0	0	1
0	0	1	0	0	0	0	0	0
0	0	0	1	0	0	0	0	0
0	0	0	0	1	1	0	0	0
0	0	0	0	0	1	0	0	0
0	0	0	0	0	0	0	0	0
0	0	0	0	0	0	0	1	1
0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0	0
+ad+ci
--><!-- test cases for hamilton cycles list

# n = 9

0	0	0	0	24	13	14	0	0
0	0	0	0	19	0	0	6	7
0	0	0	0	0	5	19	0	11
0	0	0	0	0	0	30	0	11
0	0	0	0	0	0	0	10	23
0	0	0	0	0	0	17	0	19
0	0	0	0	0	0	0	36	18
0	0	0	0	0	0	0	0	21
0	0	0	0	0	0	0	0	0
a–f–c–i–d–g–h–b–e–a

# n = 8

K_8
0	1	1	1	1	1	1	1
0	0	1	1	1	1	1	1
0	0	0	1	1	1	1	1
0	0	0	0	1	1	1	1
0	0	0	0	0	1	1	1
0	0	0	0	0	0	1	1
0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0


# square & triangle with shared vertex

0	0	0	1	0	1
0	0	1	0	0	1
0	0	0	0	1	0
0	0	0	0	0	1
0	0	0	0	0	1
0	0	0	0	0	0
+bd -> hamilton

# square and pentagon with shared edge

0	0	1	0	0	1	0
0	0	0	1	1	0	0
0	0	0	1	0	0	0
0	0	0	0	0	0	1
0	0	0	0	0	0	1
0	0	0	0	0	0	1
0	0	0	0	0	0	0
is hamiton

### examples for n = 10

0	0	0	0	0	0	0	1	0	1
0	0	1	0	0	0	0	0	0	1
0	0	0	0	0	0	1	1	0	0
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	1	0	0	0
0	0	0	0	0	0	0	1	0	0
0	0	0	0	0	0	0	0	1	0
0	0	0	0	0	0	0	0	1	0
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0	0	0
->+1 ребра de, ef, ab

0	0	0	0	1	1	0	0	0	0
0	0	0	0	0	1	0	0	0	1
0	0	0	0	0	1	0	1	0	0
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	1	0	0
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0	1	0
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0	0	0
-> +1 dg, ac

i=0

0	0	1	0	0	0	0	0	1	0
0	0	0	0	0	1	1	0	0	0
0	0	0	0	0	0	0	0	1	1
0	0	0	0	0	0	0	0	1	0
0	0	0	0	0	0	0	0	1	0
0	0	0	0	0	0	1	0	0	0
0	0	0	0	0	0	0	0	1	0
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0	0	0
-> +1 de, eh, ab


0	0	0	0	1	1	0	0	0	0
0	0	0	0	0	1	0	0	1	0
0	0	0	0	0	1	0	0	1	0
0	0	0	0	0	0	0	0	1	1
0	0	0	0	0	0	0	0	1	0
0	0	0	0	0	0	0	1	0	0
0	0	0	0	0	0	0	0	1	0
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0	0	0
-> +bg
-->

# Заключение {-}

Недостатки:
	
- в текущей реализации веса ребер должны быть ненулевые. Так, например, не получится добавить ребро нулевой цены.

# Список использованных источников {-}

::: {#refs}
:::
<!--
```{.cpp include=../L1/graphs.cpp snippet=\1}
```
// start snippet \1
// end snippet \1
-->