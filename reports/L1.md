# Введение {-}

## Постановка задачи {-}

### Лабораторная работа 1 {-}

1. Сформировать случайным образом связный ациклический граф, выходные степени вершин которого подчиняются
   распределению Пойя 1 (параметры распределения задаются как константы),
   с необходимым количеством вершин.
   <!-- Распределение лучше всего брать из справочника Вадзинского (есть в списке литературы). -->
2. Реализовать метод Шимбелла на полученном графе
   (пользователь вводит количество ребер).
3. Определить возможность построения маршрута от одной заданной точки до другой
   (вершины вводит пользователь) и указывать количество таковых маршрутов.

### Лабораторная работа 2 {-}

1. Для заданных графов (случайно сгенерированных в предыдущей работе)
   найти кратчайший путь для выбранных точек, используя алгоритмы Дейкстры, Беллмана-Форда, Флойда
   (пользователь вводит номера вершин начальной и конечной).
   Для алгоритмов Дейкстры и Беллмана-Форда рекомендуется выводить вектор расстояний,
   для Флойда-Уоршалла --- матрицу расстояний. Обязательно выводить сам путь в виде последовательности вершин.
2. Сравнить скорости работы данных алгоритмов (по количеству итераций).

### Лабораторная работа 3 {-}

1. Сформировать связный ациклический граф случайным образом в соответствии с заданным распределением.
	 На его основе построить матрицы пропускных способностей и стоимости.

2. Для полученного графа найти максимальный поток по алгоритму
	 Форда-Фалкерсона (или любого из перечисленных в лекции).

3. Вычислить поток минимальной стоимости (в качестве величины потока брать значение,
	 равное $\frac 2 3 f_{\max}$, где $f_{\max}$ --- максимальный поток).
	 Использовать ранее реализованные алгоритмы Дейкстры и/или Беллмана–Форда.

### Лабораторная работа 4 {-}

1. Для заданных графов (случайно сгенерированных в первой работе)
		построить минимальный по весу остов, используя алгоритмы Прима и Краскала.
		<!-- (алгоритм Борувки - факультативно) -->
		Сравнить данные алгоритмы (итерации).

2. Используя матричную теорему Кирхгофа, найти число остовных деревьев в графе.

3. Полученный остов закодировать с помощью кода Прюфера
		(проверить правильность кодирования декодированием).
		Желательно сохранять веса при кодировании.

### Лабораторная работа 5 {-}

1. Для заданных графов (случайно сгенерированных в первой работе) проверить,
		является ли граф эйлеровым и гамильтоновым. Если граф не является таковым,
		то отдельно модифицировать граф до эйлерова и отдельно до гамильтонова
		(до полного графа можно дополнять только в крайнем случае!).

2. Построить эйлеров цикл.

3. Решить задачу коммивояжёра на гамильтоновом графе
		(все гамильтоновы циклы с суммарным весом выводить либо на экран,
		если их мало, либо в файл).

# Математическое описание

Неориентированным графом $G(V,E)$ называется совокупность двух множеств ---
непустого множества _вершин_ $V$ и множества _рёбер_ $E$,
\begin{gather*}
G(V, E) ≝ ⟨V;E⟩,
\\ V ≠ ∅,
\\ E ⊂ 2^V ∧ ∀e ∈ E (|e| = 2).
\end{gather*}

Ориентированным графом $G(V,E)$ называется совокупность двух множеств ---
непустого множества _узлов_ $V$ и множества _дуг_ $E$,
\begin{gather*}
G(V, E) ≝ ⟨V;E⟩,\\ V ≠ ∅,\quad E ⊂ V^2.
\end{gather*}

Число вершин графа $G$ обозначим $p$, а число рёбер — $q$:
\begin{gather*}
p ≝ p(G) ≝ |V|,\\
q ≝ q(G) ≝ |E|.
\end{gather*}

<!-- степень вершины? -->

## Связность

_Маршрутом_ в графе называется чередующаяся последовательность вершин и рёбер,
начинающаяся и кончающаяся вершиной, $v_0, e_1, v_1, e_2, v_2,\dotsc, e_k, v_k$, в которой
любые два соседних элемента инцидентны, причём однородные элементы (вершины,
рёбра) через один смежны или совпадают.

Если $v_0 = v_k$, то маршрут _замкнут_, иначе — _открыт_. Если все рёбра различны,
то маршрут называется _цепью_. Если все вершины (а значит, и рёбра) различны,
то маршрут называется _простой цепью_.

Говорят, что две вершины в графе _связаны_, если
существует соединяющая их (простая) цепь. Граф, в
котором все вершины связаны, называется _связным_.

Отношение связанности вершин является эквивалентностью.
Классы эквивалентности по отношению связанности называются _компонентами связности_ графа.

Число компонентов связности графа $G$ обозначается
$k(G)$.

Граф $G$ связный $⟺ k(G) = 1$.

Если $k(G) > 1$, то $G$ — _несвязный_ граф.

Замкнутая цепь называется _циклом_; замкнутая простая цепь называется _простым
циклом_. Число циклов в графе $G$ обозначается $z(G)$. Граф без циклов называется
ациклическим ($z(G) = 0$).

## Метод Шимбелла

Пусть граф задан матрицей $Ω = (ω_{ij})$ весов ребер, т.е.
$$ ω_{ij} = \begin{cases}
	0, & \text{если вершины }i, j\text{ не смежны},\\
	ω, & \text{если вес ребра }ij = ω.
\end{cases}
$$

Введем специальные операции над элементами матрицы
смежности вершин, позволяющие находить кратчайшие или максимальные пути между
вершинами,
состоящие из заданного количества ребер. Эти операции таковы.

1) Операция умножения двух величин $a$ и $b$ при возведении матрицы в степень
соответствует их алгебраической сумме, то есть
	$$ \begin{cases}
   	a ⋅ b ≝ a+b\\
   	a ⋅ 0 = 0 ⋅ a ≝ 0
 	\end{cases}
	$$

2) Операция сложения двух величин $a$ и $b$ заменяется выбором из этих величин
минимального (максимального) элемента, то есть
	\begin{equation}
	\begin{cases}
		a+b ≝ \min (\max)\{a, b\}\\
		a + 0 = 0 + a ≝ a
	\end{cases}\label{eq:shimbell_mul}
	\end{equation} 

	нули при этом игнорируются. Минимальный или максимальный элемент выбирается из
	ненулевых элементов. Нуль в результате операции (\ref{eq:shimbell_mul}) может быть получен лишь тогда,
	когда все элементы из выбираемых --- нулевые.

С помощью этих операций длины кратчайших или максимальных путей между всеми
вершинами определяется возведением в степень весовой матрицы $Ω$, содержащей веса
ребер. Например, элементы матрицы $Ω^2 =\left(ω^{(2)}_{ij}\right)$ определяются следующим образом
$$ ω^{(2)}_{ij} = \min_k (\max_k) \left\{ω^{(1)}_{ik} + ω^{(1)}_{kj}\right\}.
$$

Аналогично определяются элементы матрицы $Ω^m =\left(ω^{(m)}_{ij}\right)$.
Длина кратчайшего или максимального пути из $m$ ребер от вершины $i$ до вершины $j$ равна $ω^{(m)}_{ij}$[@shaporev2006].

## Распределение Пойа 1

Ряд распределения дискретной случайной величины $X$ --- совокупность
всех ее возможных значений $x_1,\dotsc,x_n$, и вероятностей $p_1,\dotsc,p_n$, появления каждого из этих значений.

Примем как обозначение $∏\limits_{k=0}^{-1} f(k) = 1$ (как произведение пустого множества элементов).

Ряд распределение Пойа ---

$$ p(x) = C_n^x \frac {∏\limits_{k=0}^{x-1} (b+kc) ∏\limits_{k=0}^{n-x-1} (r+kc)} {∏\limits_{k=0}^{n-1}(b + r + kc)},
\ x=0,1,2,\dotsc, n.
$$	

В частности,
$$
p(0) = ∏_{k=0}^{n-1} \frac {r + kc}
         {b + r + kc},
\quad
p(n) = ∏_{k=0}^{n-1} \frac {b + kc}
         {b + r + kc},
$$

где $n>0$, $b>0$, $r>0$, $c ∈ ℤ$. Параметр $c$ может быть отрицательным,
однако он должен удовлетворять условию $b+r+c(n-1)>0$[@vadzinsky2001].

\begin{algorithm}
  \caption{Генерации случайного числа, подчиняющегося распределению Пойа 1}
  \label{alg:poja}
\begin{algorithmic}
\Require $n>0$, $b>0$, $r>0$, $c ∈ ℤ$
\Ensure случайное число из множества $\{0,1,\dotsc, n\}$
\State $p := p_0$
\Comment{$p_0 = p(0)$}
\State $r :=$ \Call{Rand}{}
\Comment{$r ∈ [0, 1]⊂ℝ$, случайное с равномерным распределением}
\For{$x := 0,n-1$}
	\State $r := r - p$
	\If{$r < 0$}
		\State \Return $x$
	\EndIf
	\State $p := p ⋅ α(x)$
	\Comment{$α(x) = \dfrac {(n+1-x)\left(b + (x-1)c\right)}{x \left(r + (n-x)\right) c}$}
\EndFor
\State \Return $n$
\end{algorithmic}
\end{algorithm}

## Вспомогательные процедуры

Во многих алгоритмах поиска кратчайших путей используются две процедуры.
Процедура инициализации \textsc{Init}($s$) строит начальное состояние матрицы длин путей
и матрицы предшествования.

\begin{algorithmic}
\Require узел $s$
\Ensure заполненные матрицы $T$ :\Array{1..$p$, 1..$p$}{\Real} длин путей и\\
 $Π$: \Array{1..$p$, 1..$p$}{0..$p$} самих путей.
\Procedure{Init}{$s$}
\For{$v := 1,p$}
\State $T [v] := +∞$, $Π[v] := 0$
\EndFor
\State $T[s] := 0$
\EndProcedure
\end{algorithmic}

Процедура ослабления, или релаксации, — \textsc{Relax}($s$, $v$, $u$) проверяет, возможно ли
улучшить известный путь из узла $s$ в узел $v$, проведя новый путь через узел $u$,
и обновляет пути, если это возможно.

\begin{algorithmic}
\Require узлы $s$, $v$, $u$\\
матрица $W$ : \Array{1..$p$, 1..$p$}{\Real} длин дуг,\\
матрица $T$ : \Array{1..$p$, 1..$p$}{\Real} длин путей,\\
матрица $Π$ : \Array{1..$p$, 1..$p$}{0..$p$} самих путей.
\Ensure обновленные матрицы $T$, $Π$
\Procedure{Relax}{$s$, $v$, $u$}
\If {$T [s, v] > T [s, u] + W [u, v]$}
\State $T [s, v] := T [s, u] + W [u, v]$; $Π[s, v] := u$ \Comment{новый путь короче}
\EndIf
\EndProcedure
\end{algorithmic}

Восстановление пути по матрице предшествования $Π$ можно произвести так:
<!-- 389 -->

\begin{algorithmic}
\State $w := v$; \Yield $w$ \Comment{последний узел}
\While{$w ≠ u$}
	\State $w := Π[u, w]$
	\State \Yield $w$ \Comment{предыдущий узел}
\EndWhile
\end{algorithmic}

Полученную последовательность можно обратить, если это потребуется, и получить прямой
порядок узлов пути.

## Алгоритм Дейкстры

Алгоритм Дейкстры находит кратчайший путь между двумя данными вершинами
(узлами) в (ор)графе, если длины дуг неотрицательны[@novikov2008].

_Сложность алгоритма_: $𝒪(p^2)$.

\begin{algorithm}
  \caption{Дейкстры поиска кратчайших путей}\label{alg:dejkstra}
  \begin{algorithmic}
  \Require
  	взвешенный орграф $G(V, E)$,\\
  	матрица весов $W$ : \Array{1..$p$, 1..$p$}{\Real},\\
		источник $s$.
  \Ensure
  	вектор $T$ : \Array{1..$p$}{\Real} длин кратчайших путей от источника,\\
  	вектор $Π$ : \Array{1..$p$}{0..$p$} самих путей.
  \State \Call{Init}{$s$} \Comment{инициализация}
  \State $Q:=V$ \Comment{контейнер (очередь с приоритетами)}
  \While{$Q≠∅$}
		\State $u$ := \Call{ExtractMin}{$Q$} \Comment{извлечение узла с минимальным значением $T[u]$}
		\If{$T[u] = ∞$} \Stop \EndIf \Comment{остальные узлы недостижимы из $s$}
		\ForAll{$v ∈ Γ(u)$}
			\If{$v ∈ Q$}
				\State \Call{Relax}{$s$, $v$, $u$} \Comment{релаксация дуги $(u, v)$}
			\EndIf
		\EndFor
  \EndWhile
  \end{algorithmic}
\end{algorithm}

## Алгоритм Беллмана-Форда

Алгоритм Беллмана-Форда находит кратчайшие пути во взвешенном графе,
не содержащем циклы с отрицательным суммарным весом, от одной вершины до всех остальных[@shaporev2006].

При этом алгоритм Беллмана-Форда позволяет определить наличие циклов
отрицательного веса, достижимых из начальной вершины.

_Сложность алгоритма_: $𝒪(pq)$, где $p$ — количество вершин, $q$ — количество ребер.

\begin{algorithm}
  \caption{Беллмана–Форда}\label{alg:bellman-ford}
  \begin{algorithmic}
  \Require
  	взвешенный орграф $G(V, E)$,
  	матрица весов $W$ : \Array{1..$p$, 1..$p$}{\Real},
		источник $s$.
  \Ensure
  	вектор $T$ : \Array{1..$p$}{\Real} длин кратчайших путей от источника,\\
  	вектор $Π$ : \Array{1..$p$}{0..$p$} самих путей.
  \State \Call{Init}{$s$} \Comment{инициализация}
	\For{$i := 1, p − 1$}
	\ForAll{$(u, v) ∈ E$}
	\State \Call{Relax}{$s$, $v$, $u$}
	\EndFor
	\EndFor
	\ForAll{$(u, v) ∈ E$} \Comment{проверка на отрицательные контуры}
	\If{$T [v] > T [u] + W [u, v]$}
	\Stop \Comment{найден контур отрицательного веса}
	\EndIf
	\EndFor
  \end{algorithmic}
\end{algorithm}

## Алгоритм Флойда-Уоршелла

Алгоритм Флойда-Уоршелла находит кратчайшие пути между всеми парами 
вершин (узлов) в (ор)графе. Веса ребер могут быть как положительными, так и 
отрицательными.

Для нахождения кратчайших путей между всеми вершинами графа 
используется восходящее динамическое программирование, то есть все подзадачи, которые 
впоследсвии понадобятся для решения исходной задачи, просчитываются заранее, а затем
используются[@novikov2008].

<!-- про циклы отрицательного суммарного веса -->
Алгоритм не всегда выдаёт
решение, поскольку оно не всегда определено.
Дополнительный цикл по $j$ служит
для прекращения работы в случае обнаружения в орграфе контура с отрицательным
весом.

_Идея алгоритма_ — разбиение процесса поиска кратчайших путей на фазы.

_Сложность алгоритма_: $𝒪(p^3)$.

\begin{algorithm}
  \caption{Флойда-Уоршалла поиска всех кратчайших путей}\label{alg:floydworshall}
  \begin{algorithmic}
  \Require
  	матрица $W$ : \Array{1..$p$, 1..$p$}{\Real}  длин дуг.
  \Ensure матрица $T$: \Array{1..$p$, 1..$p$}{\Real} длин путей и\\
          матрица $Π$: \Array{1..$p$, 1..$p$}{0..$p$} самих путей.
\For{$i := 1, p$} \Comment{инициализация}
\For{$j := 1, p$}
\State $T [i, j] := W [i, j]$
\If{$W[i, j] = ∞$}
\State $Π[i, j] := 0$ \Comment{нет дуги из $i$ в $j$}
\Else
\State $Π[i, j] := i$ \Comment{есть дуга из $i$ в $j$}
\EndIf
\EndFor
\EndFor
\For{$i := 1, p$}
\For{$j := 1, p$}
\For{$k := 1, p$}
\If{$\begin{cases} i ≠ j ∧ T [j, i] ≠ ∞ \\ i ≠ k ∧ T [i, k] ≠ ∞ \\ T [j, k] = ∞ ∨ T [j, k] > T [j, i] + T [i, k] \end{cases}$}
\State $T [j, k] := T [j, i] + T [i, k]$ \Comment{запомнить длину нового пути}
\State $Π[j, k] := i$ \Comment{и сам путь}
\EndIf
\EndFor
\EndFor
\For{$j := 1, p$}
\If{$T [j, j] < 0$}
\Stop \Comment{Узел $j$ входит в отрицательный контур}
\EndIf
\EndFor
\EndFor
  \end{algorithmic}
\end{algorithm}

## Максимальный поток в сети

Пусть $G(V,E,c)$ --- сеть, $s$ и $t$ --- cоответственно, источник и сток сети.
Дуги сети нагружены неотрицательными вещественными числами, $c:\ E → ℝ_+$.
Если $u$ и $v$ --- узлы сети, то число $c(u,v)$ --- называется _пропускной способностью_ дуги $(u,v)$. 

_Дивергенцией функции_ $f$ в узле $v$ называется число $\div(f, v)$, которое определяется следующим образом:

$$ \div(f,u) ≝ ∑_{v|(u,v) ∈ E} f(u,v) \quad- ∑_{v|(u,v) ∈ E} f(v,u)
$$

Функция $f: E → ℝ$ называется _потоком_ в сети $G$, если:

1. $∀ (u,v) ∈ E (0 ⩽ f(u,v) ⩽ c(u,v))$,
		то есть поток через дугу неотрицателен и не превосходит пропускной способности дуги.
2. $∀ u ∈ V ⧵ \{s,t\} (\div(f,u)=0)$, то есть дивергенция потока равна нулю во всех узлах,
		кроме источника и стока.
		_Величина потока в сети_ $G$ --- сумма всех потоков,
		выходящих из истока, то есть[@novikov2008]
		$$ w(f) = \div(f,s).
		$$

## Алгоритм Форда-Фалкерсона

_Теорема Форда-Фалкерсона_[@novikov2008]

Максимальный поток в сети равен минимальной пропускной способности разреза, то есть существует поток $f^*$ такой, что 
$$ w(f^*) = \max_f w(f) = \min_P C(P).
$$

На основе данной теоремы реализуется алгоритм Форда-Фалкерсона для определения максимального потока в сети,
заданной матрицей пропускных способностей дуг.

Алгоритм Форда-Фалкерсона решает задачу нахождения максимального потока в транспортной сети.

<!-- TODO -->

## Вычисление потока минимальной стоимости

Рассмотрим задачу определения потока заданной величины $θ$ от $s$ к $t$ в сети
$G(V,E,c,d)$, в которой каждая дуга $(u,v) ∈ E$ характеризуется не только пропускной способностью
$c(u,v)$, но и неотрицательной стоимостью $d(u,v)$ пересылки единичного потока из
$i$ в $j$ вдоль дуги $(u,v)$. $d:\ E → ℝ_+$.

Если $θ>f_{\max}$, где $f_{\max}$ --- величина максимального потока в сети $G$ от $s$ к $t$,
то решения нет.
Если же $θ⩽f_{\max}$, то может быть определено несколько различных потоков величины
$θ$ от $s$ к $t$.

Математическая модель задачи ---
минимизировать целевую функцию выбором потока $f$:

$$ ∑_{(u,v) ∈ E} d(u,v) ⋅ f(u,v) → \min_{f},
$$

где $d(u,v)$ --- вес дуги $(u,v)$, $f(u,v)$ --- величина потока вдоль дуги $(u,v)$[@shaporev2006].

## Задача определения максимального потока в сети с несколькими истоками и несколькими стоками

В задаче о максимальном потоке может быть несколько истоков и стоков. Например,
$m$ истоков $\{ s_1, s_2, \dotsc, s_m\}$ и
$n$ стоков $\{t_1,t_2, \dotsc,t_n\}$.

Задача определения максимальном потока в сети с несколькими истоками
и несколькими стоками сводится к обычной задаче о максимальном потоке.
Для этого в сеть добавляется _фиктивный исток_ (supersource) $s$
и ориентированные ребра $(s, s_i)$ с пропускной способностью
$$ c(s,s_i)=∞, \qquad i = 1,\dotsc,m.
$$
Точно так же создается _фиктивный сток_ (supresink) $t$ и добавляются ориентированные ребра $(t_i, t)$, обладающие
$$ c(t_i , t) = ∞, \qquad i=1,\dotsc,n.
$$

Единственный исток $s$ обеспечивает поток любой требуемой величины к истокам $s_i$, а единственный сток $t$ аналогичным образом потребляет поток любой желаемой величины от множественных стоков $t_i$[@cormen2013].

## Минимальный остов

_Остовным деревом_ или _остовом_ графа $G(V, E)$ называется связный подграф без циклов, содержащий все вершины исходного графа.
Любое остовное дерево в графе с $|V| = n$ вершинами
содержит ровно $n-1$ ребро.

_Минимальное остовное дерево_ — это остовное дерево,
сумма весов ребер которого минимальна.

_Задача о минимальном остове_: во взвешенном связном графе найти остов минимального веса, то есть остов, суммарный вес ребер которого является минимальным[@novikov2008].

## Алгоритм Прима

Алгоритм Прима --- алгоритм построения минимального остовного дерева взвешенного связного неориентированного графа.

В данном алгоритме кратчайший остов порождается в процессе разрастания одного дерева, к которому присоединяются ближайшие одиночные вершины.
При этом для каждой вершины $v$, кроме начальной,
используются две пометки: $α[v]$ — это ближайшая
к $v$ вершина, уже включённая в остов, а $β[v]$ — это длина ребра, соединяющего $v$ с остовом.
Если вершину $v$ ещё нельзя соединить с остовом одним ребром, то
$α[v] := 0$, $β[v] := ∞$.

На выходе мы получаем множество ребер, которые лежат в минимальном остовном дереве[@novikov2008].

\begin{algorithm}
\caption{Прима, нахождения остовного дерева минимальной стоимости}\label{alg:prim}
\begin{algorithmic}
\Require граф $G(V, E)$, заданный матрицей длин рёбер $C$.
\Ensure множество $T$ рёбер кратчайшего остова.
\State \Select $u ∈ V$ \Comment{выбираем произвольную вершину}
\State $S :=\{u\}$ \Comment{$S$ — множество вершин, включённых в кратчайший остов}
\State $T := ∅$ \Comment{$T$ — множество рёбер, включённых в кратчайший остов}
\For{$v ∈ V − u$}
\If{$v ∈ Γ(u)$}
\State $α[v] := u$ \Comment{$u$ — ближайшая вершина остова}
\State $β[v] := C[u, v]$ \Comment{$C[u, v]$ — длина соответствующего ребра}
\Else
\State $α[v] := 0$ \Comment{ближайшая вершина остова неизвестна}
\State $β[v] := ∞$ \Comment{и расстояние также неизвестно}
\EndIf
\EndFor
\For{$i:=1,p−1$}
\State $x := ∞$ \Comment{начальное значение для поиска ближайшей вершины}
\For{$v ∈ V ⧵ S$}
\If{$β[v] < x$}
\State $w := v$ \Comment{нашли более близкую вершину}
\State $x := β[v]$ \Comment{и расстояние до неё}
\EndIf
\EndFor
\State $S := S + w$ \Comment{добавляем найденную вершину в остов}
\State $T := T + (α[w], w)$ \Comment{добавляем найденное ребро в остов}
\For{$v ∈ Γ(w)$}
\If{$v ∉ S ∧ β[v] > C[v, w]$}
\State $α[v] := w$ \Comment{изменяем ближайшую вершину остова}
\State $β[v] := C[v, w]$ \Comment{и длину ведущего к ней ребра}
\EndIf
\EndFor
\EndFor
\end{algorithmic}
\end{algorithm}

_Сложность алгоритма_: $𝒪(n^2)$.

## Алгоритм Краскала

Алгоритм Краскала --- жадный алгоритм построения минимального остовного дерева
взвешенного связного неориентированного графа.

Алгоритм \ref{alg:kruskal} состоит из двух фаз.

1. На подготовительной фазе все дуги удаляются из дерева и упорядочиваются по возрастанию их весов.
		В графе остаются только вершины, каждая из которых образует отдельную компоненту связности.

2. Во второй фазе дуги перебираются в порядке возрастания веса.
		Если начало и конец очередной дуги принадлежат одной и той же компоненте связности, дуга игнорируется.
		Если же они лежат в разных компонентах связности. дуга добавляется к графу,
		а эти две компоненты связности объединяются в одну.
		Если число компонент связности дойдет до 1, цикл прерывается.

_Сложность алгоритма_: $𝒪(q \log p)$, где
$p$ --- количество вершин,
$q$ --- количество ребер графа.

\begin{algorithm}
\caption{Краскала, нахождения остовного дерева минимальной стоимости}
\label{alg:kruskal}
\begin{algorithmic}
  \Require
  	список $E$ рёбер графа $G$ с длинами,
  	упорядоченный в порядке возрастания длин.
  \Ensure множество $T$ рёбер кратчайшего остова.
\State $T :=∅$
\State $k := 1$ \Comment{номер рассматриваемого ребра}
\For{$i := 1, p − 1$}
\While{$z(T + E[k]) > 0$}
\State $k := k + 1$ \Comment{пропустить это ребро}
\EndWhile
\State $T := T + E[k]$ \Comment{добавить это ребро в SST}
\State $k := k + 1$ \Comment{и исключить его из рассмотрения}
\EndFor
\end{algorithmic}
\end{algorithm}
<!-- SST — Shortest Spanning Tree — стандартное обозначение для кратчайшего остова. -->

## Матричная теорема Кирхгофа

_Матрица Кирхгофа_ --- матрица
$B(G) = (β_{ij})_{p×p} = \diag\{\deg v_i\}-A(G)$,
где $p$ --- количество вершин графа.
$A(G) = (α_{ij})_{p×p} = (v_i ∈ Γ(v_j))$ --- матрица смежности.
$$ β_{ij} = \begin{cases}
-1,&  \text{если $v_i$ смежна с $v_j$;}\\
0,  &\text{если $i ≠ j$, $v_i$ не смежна с $v_j$;}\\
\deg v_i,&  \text{если $i = j$.}
\end{cases}
$$

### Свойства матрицы Кирхгофа

1. Суммы элементов в каждой строке и каждом столбце матрице равны 0.
2. Алгебраические дополнения всех элементов матрицы равны между собой.
3. Определитель матрицы Кирхгофа равен нулю.

_Матричная теорема Кирхгофа_

Число остовных деревьев в связном графе $G$ порядка $p ⩾ 2$ равно
алгебраическому дополнению $A_{ij}$ любого элемента матрицы Кирхгофа $B(G)$[@shaporev2006].
$$ A_{ij} = (-1)^{i+j} |M_{ij}|,
$$
где $|M_{ij}|$ --- минор, полученный из матрицы $B$ вычеркиванием $i$-й строки и $j$-го столбца.

## Код Прюфера

_Код Прюфера_ --- это способ взаимно однозначного кодирования помеченных деревьев с $p$ вершинами с помощью последовательности $p-2$ целых чисел в отрезке $[1,p]$. То есть, код Прюфера --- это биекция между всеми остовными деревьями полного графа и числовыми последовательностями.

\begin{algorithm}
\caption{Построение кода Прюфера свободного дерева}
\label{alg:pruefer-encode}
\begin{algorithmic}
\Require Дерево $T(V, E)$ в любом представлении, вершины дерева пронумерованы
числами $1..p$ произвольным образом.
\Ensure Массив $A$: \Array{1..$p − 1$}{1..$p$}
— код Прюфера дерева $T$.
\For{$i := 1, p−1$}
\State $v := \min \{k ∈ V | d(k) = 1\}$ \Comment{выбираем висячую вершину $v$}
\State $A[i] := Γ(v)$ \Comment{заносим в код номер единственной вершины, смежной с $v$}
\State $V := V − v$ \Comment{удаляем вершину $v$ из дерева}
\EndFor
\end{algorithmic}
\end{algorithm}

_Сложность алгоритма_ \ref{alg:pruefer-encode}: $𝒪(p \log p)$, если поиск минимума осуществляется за $𝒪(\log p)$.

Восстанавление закодированного по коду Прюфера дерева --- алгоритм \ref{alg:pruefer-decode}.

\begin{algorithm}
\caption{Распаковка кода Прюфера свободного дерева}
\label{alg:pruefer-decode}
\begin{algorithmic}
\Require Массив $A$: \Array{1..$p − 1$}{1..$p$}
— код Прюфера дерева $T$.
\Ensure Дерево $T(V, E)$, заданное множеством рёбер $E$, вершины
пронумерованы числами $1..p$.
\State $E : = ∅$ \Comment{вначале множество рёбер пусто}
\State $B : = 1..p$ \Comment{множество неиспользованных номеров вершин}
\For{$i := 1,p − 1$}
\State \Comment{выбираем вершину $v$ — неиспользованную вершину с наименьшим}
\State \Comment{номером, который не встречается в остатке кода Прюфера}
\State $v : = \min \left\{k ∈ B \middle| ∀ j ⩾ i (k ≠ A[j])\right\}$
\State $E : = E + (v, A[i])$ \Comment{добавляем ребро $(v, A[i])$}
\State $B : = B − v$ \Comment{удаляем вершину $v$ из списка неиспользованных}
\EndFor
\end{algorithmic}
\end{algorithm}

_Сложность алгоритма_ \ref{alg:pruefer-decode}: $𝒪(p \log p)$, если поиск минимума осуществляется за $𝒪(\log p)$.

## Эйлеров граф

Если связный граф имеет цикл (не обязательно простой),
содержащий все рёбра графа (каждое --- по одному разу),
то такой цикл называется _эйлеровым_ циклом,
а граф называется _эйлеровым_ графом.
Эйлеров цикл содержит все вершины графа.

_Теорема_ Если граф $G$ связен и нетривиален,
то $G$ — эйлеров граф $⟺$ каждая вершина $G$ имеет чётную степень[@novikov2008].
<!--
Алгоритм 10.1. Построение эйлерова цикла
Вход: эйлеров граф G(V, E), заданный списками смежности (Γ[v] — список вершин,
смежных с вершиной v).
Выход: последовательность вершин эйлерова цикла.
S : = ∅ // стек для хранения вершин
select v ∈ V // произвольная вершина
v → S // положить v в стек S
while S ≠ ∅ do
v : = top S // v — верхний элемент стека
if Γ[v] = ∅ then
v ← S; yield v // очередная вершина эйлерова цикла
else
select u ∈ Γ[v] // взять первую вершину из списка смежности
u → S // положить u в стек
Γ[v] : = Γ[v] − u; Γ[u] : = Γ[u] − v // удалить ребро (v, u)
end if
end while
-->

## Гамильтонов граф

Если граф имеет простой цикл, содержащий все вершины графа (по одному разу), то такой цикл называется _гамильтоновым_ циклом, а граф называется _гамильтоновым_ графом.

Гамильтонов цикл не обязательно содержит все ребра графа. Гамильтоновым может быть только связный граф.

_Достаточное условие гамильтоновости графа_ (условие Дирака):

Если $p(G)⩾3$ и $δ(G) ⩾ \frac p 2$, то граф $G$ является гамильтоновым[@novikov2008].

## Задача коммивояжёра

Формулировка задачи: имеется $p$ городов, расстояния между которым известны. Коммивояжёр должен посетить все $p$ городов по одному разу, вернувшись в тот, с которого начал. Требуется найти такой маршрут движения, при котором суммарное пройденное расстояние будет минимальным. То есть, задача коммивояжёра --- задача отыскания кратчайшего гамильтонова цикла в нагруженном полном графе.
$$ ∑_{(u,v) ∈ E} w(u,v) → \min_{E}
$$

<!--
Проблему коммивояжёра можно представить в виде модели на графе, то есть, используя вершины и ребра между ними. Таким образом, вершины графа соответствуют городам, а рёбра $\left(i,j\right)$ между вершинами$i$ и $j$ — пути сообщения между этими городами. Каждому ребру $\left(i,j\right)$ можно сопоставить критерий выгодности маршрута $c_{ij}⩾0$, который можно рассматривать как, расстояние между городами, время или стоимость поездки.
-->


<!--
Пусть $1,p_1, p_2, \dots, p_{n-1}, 1$ -- номера городов, записанные в порядке их обхода. То есть $p_k$ -- номер города, посещаемого на $k$-м шаге, $k =0, \dots, n$, $p_0=p_n=1$. Тогда пройденное расстояние можно представить в виде целевой функции:
$$\sum_{k=0}^{n-1}c[p_k][p_{k+1}]$$
Среди чисел $p_1, p_2, \dots, p_{n-1}$ по одному разу встречается каждое число из интервала $2..n$. Таким образом задача коммивояжера состоит в поиске перестановки целых чисел от 2 до $n$, при которой целевая функция минимальна.

Схема решения	задачи	коммивояжёра:	
сгенерировать	все	р!		возможных	перестановок	вершин	полного	 графа,	подсчитать	для	каждой	перестановки	длину 	маршрута	и	выбрать	из	них	кратчайший.	
 Очевидно,	такое 	вычисление	потребует	не	менее	 ,О(р!)		шагов.



\subsection{Существование маршрута}
\par  \textbf{Теорема:}
\par Для определения количества маршрутов, состоящих из k рёбер, необходимо возвести в k-ую степень матрицу смежности вершин. Тогда элемент p_{ij} полученной матрицы даст количество маршрутов длины k из v_i в v_j .
\par  \textbf{Следствие:}
В графе G, заданном матрицей смежности P размера n × n \, (|V| = n), \, ∃ маршрут vi → vj ⇔ элемент p_ij матрицы P + P^2+P^3 + ... + P^{n−1} не равен нулю.

 -->

# Особенности реализации

## Генерация графа

Ориентированный взвешенный граф представлен в программе матрицей весов ребер.

Отсутствие циклов гарантируется тем, что заполняются только элементы матрицы выше главной диагонали,
т. о. получается верхнетреугольная матрица.

Связность гарантируется тем, что генерируемые степени вершин $\deg^+ v > 0$, кроме одной вершины.

Веса ребер также подчиняются тому же распределению.

## Модификация г до эйлерова

1. Найти вершины с нечётной степенью
2. Выбрать паросочетание из них, желательно чтобы такого ребра ещё не было (т.е. минимальное паросочетание для булевой матрицы смежности)
3. Для каждой пары вершин из паросочетания, добавить ребро если его не было, удалить если было
4. Если граф стал несвязный, то
5. Если 3 к.с. или больше, соединить компоненты связности в цепь, выбрав в каждой из них по одной вершине, через которую она проходит.
6. Если компонент связности 2, то соединить 2 пары вершин из обеих.

# Результаты работы программы

<!-- test cases for eulerize:

# n = 10

0	0	1	0	0	0	0	0	1	1
0	0	0	0	0	0	1	0	0	1
0	0	0	0	1	0	0	0	1	0
0	0	0	0	1	0	1	0	0	0
0	0	0	0	0	0	0	0	1	1
0	0	0	0	0	0	1	0	0	1
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0	1	0
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0	0	0

+ah, -ci

# n = 4

△_

0	1	0	0
0	0	1	1
0	0	0	1
0	0	0	0

+ac +bc

# n = 4 

☒

0	1	1	1
0	0	1	1
0	0	0	1
0	0	0	0

-ab, cd

# n = 6

△_△

0	1	1	0	0	0
0	0	1	0	0	0
0	0	0	1	0	0
0	0	0	0	1	1
0	0	0	0	0	1
0	0	0	0	0	0

+ad
-ac


# n = 4

0	1	1	0
0	0	0	1
0	0	0	1
0	0	0	0

-bc

# n = 9

0	1	1	0	0	0	0	0	1
0	0	1	0	0	0	0	0	0
0	0	0	1	0	0	0	0	0
0	0	0	0	1	1	0	0	0
0	0	0	0	0	1	0	0	0
0	0	0	0	0	0	0	0	0
0	0	0	0	0	0	0	1	1
0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0	0

+ad, ci

 -->

<!-- test cases for hamilton cycles list

# n = 9

0	0	0	0	24	13	14	0	0
0	0	0	0	19	0	0	6	7
0	0	0	0	0	5	19	0	11
0	0	0	0	0	0	30	0	11
0	0	0	0	0	0	0	10	23
0	0	0	0	0	0	17	0	19
0	0	0	0	0	0	0	36	18
0	0	0	0	0	0	0	0	21
0	0	0	0	0	0	0	0	0

a–f–c–i–d–g–h–b–e–a

# n = 8

K_8

0	1	1	1	1	1	1	1
0	0	1	1	1	1	1	1
0	0	0	1	1	1	1	1
0	0	0	0	1	1	1	1
0	0	0	0	0	1	1	1
0	0	0	0	0	0	1	1
0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0


# square & triangle with shared vertex

0	0	0	1	0	1
0	0	1	0	0	1
0	0	0	0	1	0
0	0	0	0	0	1
0	0	0	0	0	1
0	0	0	0	0	0

+bd -> hamilton

# square and pentagon with shared edge

0	0	1	0	0	1	0
0	0	0	1	1	0	0
0	0	0	1	0	0	0
0	0	0	0	0	0	1
0	0	0	0	0	0	1
0	0	0	0	0	0	1
0	0	0	0	0	0	0

is hamiton

### examples for n = 10

0	0	0	0	0	0	0	1	0	1
0	0	1	0	0	0	0	0	0	1
0	0	0	0	0	0	1	1	0	0
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	1	0	0	0
0	0	0	0	0	0	0	1	0	0
0	0	0	0	0	0	0	0	1	0
0	0	0	0	0	0	0	0	1	0
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0	0	0

->+1 ребра de, ef, ab

0	0	0	0	1	1	0	0	0	0
0	0	0	0	0	1	0	0	0	1
0	0	0	0	0	1	0	1	0	0
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	1	0	0
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0	1	0
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0	0	0

-> +1 dg, ac

i=0

0	0	1	0	0	0	0	0	1	0
0	0	0	0	0	1	1	0	0	0
0	0	0	0	0	0	0	0	1	1
0	0	0	0	0	0	0	0	1	0
0	0	0	0	0	0	0	0	1	0
0	0	0	0	0	0	1	0	0	0
0	0	0	0	0	0	0	0	1	0
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0	0	0

-> +1 de, eh, ab


0	0	0	0	1	1	0	0	0	0
0	0	0	0	0	1	0	0	1	0
0	0	0	0	0	1	0	0	1	0
0	0	0	0	0	0	0	0	1	1
0	0	0	0	0	0	0	0	1	0
0	0	0	0	0	0	0	1	0	0
0	0	0	0	0	0	0	0	1	0
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0	0	1
0	0	0	0	0	0	0	0	0	0

-> +bg


 -->

# Заключение {-}

Недостатки:

- в текущей реализации веса ребер должны быть ненулевые. Так, например, не получится добавить фиктивное ребро нулевой цены.

# Список использованных источников {-}

::: {#refs}
:::