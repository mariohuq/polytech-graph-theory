# Введение {-}

## Постановка задачи {-}

### Лабораторная работа 1 {-}

1. Сформировать случайным образом связный ациклический граф, выходные степени вершин которого подчиняются
   распределению Пойя 1 (параметры распределения задаются как константы),
   с необходимым количеством вершин.
   <!-- Распределение лучше всего брать из справочника Вадзинского (есть в списке литературы). -->
2. Реализовать метод Шимбелла на полученном графе
   (пользователь вводит количество ребер).
3. Определить возможность построения маршрута от одной заданной точки до другой
   (вершины вводит пользователь) и указывать количество таковых маршрутов.

### Лабораторная работа 2 {-}

1. Для заданных графов (случайно сгенерированных в предыдущей работе)
   найти кратчайший путь для выбранных точек, используя алгоритмы Дейкстры, Беллмана-Форда, Флойда
   (пользователь вводит номера вершин начальной и конечной).
   Для алгоритмов Дейкстры и Беллмана-Форда рекомендуется выводить вектор расстояний,
   для Флойда-Уоршалла --- матрицу расстояний. Обязательно выводить сам путь в виде последовательности вершин.
2. Сравнить скорости работы данных алгоритмов (по количеству итераций).

### Лабораторная работа 3 {-}

1. Сформировать связный ациклический граф случайным образом в соответствии с заданным распределением.
	 На его основе построить матрицы пропускных способностей и стоимости.

2. Для полученного графа найти максимальный поток по алгоритму
	 Форда-Фалкерсона (или любого из перечисленных в лекции).

3. Вычислить поток минимальной стоимости (в качестве величины потока брать значение,
	 равное $\frac 2 3 \max$, где $\max$ --- максимальный поток).
	 Использовать ранее реализованные алгоритмы Дейкстры и/или Беллмана–Форда.

# Математическое описание

Неориентированным графом $G(V,E)$ называется совокупность двух множеств ---
непустого множества _вершин_ $V$ и множества _рёбер_ $E$,
\begin{gather*}
G(V, E) ≝ ⟨V;E⟩,
\\ V ≠ ∅,
\\ E ⊂ 2^V ∧ ∀e ∈ E (|e| = 2).
\end{gather*}

Ориентированным графом $G(V,E)$ называется совокупность двух множеств ---
непустого множества _узлов_ $V$ и множества _дуг_ $E$,
\begin{gather*}
G(V, E) ≝ ⟨V;E⟩,\\ V ≠ ∅,\quad E ⊂ V^2.
\end{gather*}

Число вершин графа $G$ обозначим $p$, а число рёбер — $q$:
\begin{gather*}
p ≝ p(G) ≝ |V|,\\
q ≝ q(G) ≝ |E|.
\end{gather*}

<!-- степень вершины? -->

## Связность

_Маршрутом_ в графе называется чередующаяся последовательность вершин и рёбер,
начинающаяся и кончающаяся вершиной, $v_0, e_1, v_1, e_2, v_2,\dotsc, e_k, v_k$, в которой
любые два соседних элемента инцидентны, причём однородные элементы (вершины,
рёбра) через один смежны или совпадают.

Если $v_0 = v_k$, то маршрут _замкнут_, иначе — _открыт_. Если все рёбра различны,
то маршрут называется _цепью_. Если все вершины (а значит, и рёбра) различны,
то маршрут называется _простой цепью_.

Говорят, что две вершины в графе _связаны_, если
существует соединяющая их (простая) цепь. Граф, в
котором все вершины связаны, называется _связным_.

Отношение связанности вершин является эквивалентностью.
Классы эквивалентности по отношению связанности называются _компонентами связности_ графа.

Число компонентов связности графа $G$ обозначается
$k(G)$.

Граф $G$ связный $⟺ k(G) = 1$.

Если $k(G) > 1$, то $G$ — _несвязный_ граф.

Замкнутая цепь называется _циклом_; замкнутая простая цепь называется _простым
циклом_. Число циклов в графе $G$ обозначается $z(G)$. Граф без циклов называется
ациклическим ($z(G) = 0$).

## Метод Шимбелла

Пусть граф задан матрицей $Ω = (ω_{ij})$ весов ребер, т.е.
$$ ω_{ij} = \begin{cases}
	0, & \text{если вершины }i, j\text{ не смежны},\\
	ω, & \text{если вес ребра }ij = ω.
\end{cases}
$$

Введем специальные операции над элементами матрицы
смежности вершин, позволяющие находить кратчайшие или максимальные пути между
вершинами,
состоящие из заданного количества ребер. Эти операции таковы.

1) Операция умножения двух величин $a$ и $b$ при возведении матрицы в степень
соответствует их алгебраической сумме, то есть
	$$ \begin{cases}
   	a ⋅ b ≝ a+b\\
   	a ⋅ 0 = 0 ⋅ a ≝ 0
 	\end{cases}
	$$

2) Операция сложения двух величин $a$ и $b$ заменяется выбором из этих величин
минимального (максимального) элемента, то есть
	\begin{equation}
	\begin{cases}
		a+b ≝ \min (\max)\{a, b\}\\
		a + 0 = 0 + a ≝ a
	\end{cases}\label{eq:shimbell_mul}
	\end{equation} 

	нули при этом игнорируются. Минимальный или максимальный элемент выбирается из
	ненулевых элементов. Нуль в результате операции (\ref{eq:shimbell_mul}) может быть получен лишь тогда,
	когда все элементы из выбираемых --- нулевые.

С помощью этих операций длины кратчайших или максимальных путей между всеми
вершинами определяется возведением в степень весовой матрицы $Ω$, содержащей веса
ребер. Например, элементы матрицы $Ω^2 =\left(ω^{(2)}_{ij}\right)$ определяются следующим образом
$$ ω^{(2)}_{ij} = \min_k (\max_k) \left\{ω^{(1)}_{ik} + ω^{(1)}_{kj}\right\}.
$$

Аналогично определяются элементы матрицы $Ω^m =\left(ω^{(m)}_{ij}\right)$.
Длина кратчайшего или максимального пути из $m$ ребер от вершины $i$ до вершины $j$ равна $ω^{(m)}_{ij}$[@shaporev2006].

## Распределение Пойа 1

Ряд распределения дискретной случайной величины $X$ --- совокупность
всех ее возможных значений $x_1,\dotsc,x_n$, и вероятностей $p_1,\dotsc,p_n$, появления каждого из этих значений.

Примем как обозначение $∏\limits_{k=0}^{-1} f(k) = 1$ (как произведение пустого множества элементов).

Ряд распределение Пойа ---

$$ p(x) = C_n^x \frac {∏\limits_{k=0}^{x-1} (b+kc) ∏\limits_{k=0}^{n-x-1} (r+kc)} {∏\limits_{k=0}^{n-1}(b + r + kc)},
\ x=0,1,2,\dotsc, n.
$$	

В частности,
$$
p(0) = ∏_{k=0}^{n-1} \frac {r + kc}
         {b + r + kc},
\quad
p(n) = ∏_{k=0}^{n-1} \frac {b + kc}
         {b + r + kc},
$$

где $n>0$, $b>0$, $r>0$, $c ∈ ℤ$. Параметр $c$ может быть отрицательным,
однако он должен удовлетворять условию $b+r+c(n-1)>0$[@vadzinsky2001].

\begin{algorithm}
  \caption{Генерации случайного числа, подчиняющегося распределению Пойа 1}
  \label{alg:poja}
\begin{algorithmic}
\Require $n>0$, $b>0$, $r>0$, $c ∈ ℤ$
\Ensure случайное число из множества $\{0,1,\dotsc, n\}$
\State $p := p_0$
\Comment{$p_0 = p(0)$}
\State $r :=$ \Call{Rand}{}
\Comment{$r ∈ [0, 1]⊂ℝ$, случайное с равномерным распределением}
\For{$x := 0,n-1$}
	\State $r := r - p$
	\If{$r < 0$}
		\State \Return $x$
	\EndIf
	\State $p := p ⋅ α(x)$
	\Comment{$α(x) = \dfrac {(n+1-x)\left(b + (x-1)c\right)}{x \left(r + (n-x)\right) c}$}
\EndFor
\State \Return $n$
\end{algorithmic}
\end{algorithm}

## Вспомогательные процедуры

Во многих алгоритмах поиска кратчайших путей используются две процедуры.
Процедура инициализации \textsc{Init}($s$) строит начальное состояние матрицы длин путей
и матрицы предшествования.

\begin{algorithmic}
\Require узел $s$
\Ensure заполненные матрицы $T$ :\Array{1..$p$, 1..$p$}{\Real} длин путей и\\
 $Π$: \Array{1..$p$, 1..$p$}{0..$p$} самих путей.
\Procedure{Init}{$s$}
\For{$v := 1,p$}
\State $T [v] := +∞$, $Π[v] := 0$
\EndFor
\State $T[s] := 0$
\EndProcedure
\end{algorithmic}

Процедура ослабления, или релаксации, — \textsc{Relax}($s$, $v$, $u$) проверяет, возможно ли
улучшить известный путь из узла $s$ в узел $v$, проведя новый путь через узел $u$,
и обновляет пути, если это возможно.

\begin{algorithmic}
\Require узлы $s$, $v$, $u$\\
матрица $W$ : \Array{1..$p$, 1..$p$}{\Real} длин дуг,\\
матрица $T$ : \Array{1..$p$, 1..$p$}{\Real} длин путей,\\
матрица $Π$ : \Array{1..$p$, 1..$p$}{0..$p$} самих путей.
\Ensure обновленные матрицы $T$, $Π$
\Procedure{Relax}{$s$, $v$, $u$}
\If {$T [s, v] > T [s, u] + W [u, v]$}
\State $T [s, v] := T [s, u] + W [u, v]$; $Π[s, v] := u$ \Comment{новый путь короче}
\EndIf
\EndProcedure
\end{algorithmic}

Восстановление пути по матрице предшествования $Π$ можно произвести так:
<!-- 389 -->

\begin{algorithmic}
\State $w := v$; \Yield $w$ \Comment{последний узел}
\While{$w ≠ u$}
	\State $w := Π[u, w]$
	\State \Yield $w$ \Comment{предыдущий узел}
\EndWhile
\end{algorithmic}

Полученную последовательность можно обратить, если это потребуется, и получить прямой
порядок узлов пути.

## Алгоритм Дейкстры

Алгоритм Дейкстры находит кратчайший путь между двумя данными вершинами
(узлами) в (ор)графе, если длины дуг неотрицательны[@novikov2008].

_Сложность алгоритма_: $O(p^2)$.

\begin{algorithm}
  \caption{Дейкстры поиска кратчайших путей}\label{dejkstra}
  \begin{algorithmic}
  \Require
  	взвешенный орграф $G(V, E)$,\\
  	матрица весов $W$ : \Array{1..$p$, 1..$p$}{\Real},\\
		источник $s$.
  \Ensure
  	вектор $T$ : \Array{1..$p$}{\Real} длин кратчайших путей от источника,\\
  	вектор $Π$ : \Array{1..$p$}{0..$p$} самих путей.
  \State \Call{Init}{$s$} \Comment{инициализация}
  \State $Q:=V$ \Comment{контейнер (очередь с приоритетами)}
  \While{$Q≠∅$}
		\State $u$ := \Call{ExtractMin}{$Q$} \Comment{извлечение узла с минимальным значением $T[u]$}
		\If{$T[u] = ∞$} \Stop \EndIf \Comment{остальные узлы недостижимы из $s$}
		\ForAll{$v ∈ Γ(u)$}
			\If{$v ∈ Q$}
				\State \Call{Relax}{$s$, $v$, $u$} \Comment{релаксация дуги $(u, v)$}
			\EndIf
		\EndFor
  \EndWhile
  \end{algorithmic}
\end{algorithm}

## Алгоритм Беллмана-Форда

Алгоритм Беллмана-Форда находит кратчайшие пути во взвешенном графе,
не содержащем циклы с отрицательным суммарным весом, от одной вершины до всех остальных[@shaporev2006].

При этом алгоритм Беллмана-Форда позволяет определить наличие циклов
отрицательного веса, достижимых из начальной вершины.

_Сложность алгоритма_: $O(pq)$, где $p$ — количество вершин, $q$ — количество ребер.

\begin{algorithm}
  \caption{Беллмана–Форда}\label{bellman-ford}
  \begin{algorithmic}
  \Require
  	взвешенный орграф $G(V, E)$,
  	матрица весов $W$ : \Array{1..$p$, 1..$p$}{\Real},
		источник $s$.
  \Ensure
  	вектор $T$ : \Array{1..$p$}{\Real} длин кратчайших путей от источника,\\
  	вектор $Π$ : \Array{1..$p$}{0..$p$} самих путей.
  \State \Call{Init}{$s$} \Comment{инициализация}
	\For{$i := 1, p − 1$}
	\ForAll{$(u, v) ∈ E$}
	\State \Call{Relax}{$s$, $v$, $u$}
	\EndFor
	\EndFor
	\ForAll{$(u, v) ∈ E$} \Comment{проверка на отрицательные контуры}
	\If{$T [v] > T [u] + W [u, v]$}
	\Stop \Comment{найден контур отрицательного веса}
	\EndIf
	\EndFor
  \end{algorithmic}
\end{algorithm}

## Алгоритм Флойда-Уоршелла

Алгоритм Флойда-Уоршелла находит кратчайшие пути между всеми парами 
вершин (узлов) в (ор)графе. Веса ребер могут быть как положительными, так и 
отрицательными.

Для нахождения кратчайших путей между всеми вершинами графа 
используется восходящее динамическое программирование, то есть все подзадачи, которые 
впоследсвии понадобятся для решения исходной задачи, просчитываются заранее, а затем
используются[@novikov2008].

<!-- про циклы отрицательного суммарного веса -->
Алгоритм не всегда выдаёт
решение, поскольку оно не всегда определено.
Дополнительный цикл по $j$ служит
для прекращения работы в случае обнаружения в орграфе контура с отрицательным
весом.

_Идея алгоритма_ — разбиение процесса поиска кратчайших путей на фазы.

_Сложность алгоритма_: $O(p^3)$.

\begin{algorithm}
  \caption{Флойда–Уоршалла поиска всех кратчайших путей}\label{floydworshall}
  \begin{algorithmic}
  \Require
  	матрица $W$ : \Array{1..$p$, 1..$p$}{\Real}  длин дуг.
  \Ensure матрица $T$: \Array{1..$p$, 1..$p$}{\Real} длин путей и\\
          матрица $Π$: \Array{1..$p$, 1..$p$}{0..$p$} самих путей.
\For{$i := 1, p$} \Comment{инициализация}
\For{$j := 1, p$}
\State $T [i, j] := W [i, j]$
\If{$W[i, j] = ∞$}
\State $Π[i, j] := 0$ \Comment{нет дуги из $i$ в $j$}
\Else
\State $Π[i, j] := i$ \Comment{есть дуга из $i$ в $j$}
\EndIf
\EndFor
\EndFor
\For{$i := 1, p$}
\For{$j := 1, p$}
\For{$k := 1, p$}
\If{$\begin{cases} i ≠ j ∧ T [j, i] ≠ ∞ \\ i ≠ k ∧ T [i, k] ≠ ∞ \\ T [j, k] = ∞ ∨ T [j, k] > T [j, i] + T [i, k] \end{cases}$}
\State $T [j, k] := T [j, i] + T [i, k]$ \Comment{запомнить длину нового пути}
\State $Π[j, k] := i$ \Comment{и сам путь}
\EndIf
\EndFor
\EndFor
\For{$j := 1, p$}
\If{$T [j, j] < 0$}
\Stop \Comment{Узел $j$ входит в отрицательный контур}
\EndIf
\EndFor
\EndFor
  \end{algorithmic}
\end{algorithm}

## Минимальный остов

_Остовным деревом_ или _остовом_ графа $G(V, E)$ называется связный подграф без
циклов, содержащий все вершины исходного графа. Подграф содержит часть или
все ребра исходного графа.

_Минимальное остовное дерево_ — это остовное дерево, сумма весов ребер которого
минимальна.

## Алгоритм Прима

## Алгоритм Краскала

<!--
## Матричная теорема Кирхгофа
## Код Прюфера
-->

# Особенности реализации

## Генерация графа

Ориентированный взвешенный граф представлен в программе матрицей весов ребер.

Отсутствие циклов гарантируется тем, что заполняются только элементы матрицы выше главной диагонали,
т. о. получается верхнетреугольная матрица.

Связность гарантируется тем, что генерируемые степени вершин $\deg^+ v > 0$, кроме одной вершины.

Веса ребер также подчиняются тому же распределению.

# Результаты работы программы

# Заключение {-}

# Список использованных источников {-}

::: {#refs}
:::