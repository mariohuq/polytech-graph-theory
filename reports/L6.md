# Введение {-}

## Постановка задачи {-}

1. Для выбранного текста на русском языке построить словарь на основе красно-черных деревьев. Реализовать функции добавления, удаления и поиска слова. Добавить функцию полной очистки словаря и загрузки/дополнения словаря из текстового файла.

2. Реализовать структуру данных --- хеш-таблицу, для которой характерны операции: добавления, удаления и поиска. На ее основе реализовать приложение --- словарь. В качестве хеш-функции, можно выбрать произвольную функцию, например, брать первую букву слова. Добавить функцию полной очистки словаря и загрузки/дополнения словаря из текстового файла. 

3. Для выбранного текста на русском языке построить словарь на основе B+-деревьев. Реализовать функции добавления, удаления и поиска слова. Добавить функцию полной очистки словаря и дополнения словаря из текстового файла.

4. Минимальная реализация включает либо пункты 1 и 2, либо пункт 2 и 3. Улучшенная реализация --- все три пункта.

Максимальная реализация также включает возможность оптимизации словаря (например, поиск потенциальных однокоренных слов в разных формах; самый простой критерий - $\dfrac 2 3$ длины слова). Выбор слов, которые следует оставить в словаре --- за пользователем.

Использовать готовые решения из стандартной библиотеки не разрешается.

# Математическое описание

## Красно-черное дерево

_Красно-черное дерево_ представляет собой бинарное дерево поиска с одним
дополнительным битом _цвета_ в каждом узле. Цвет узла может быть либо красным (`RED`), либо черным (`BLACK`). В соответствии с накладываемыми на узлы
дерева ограничениями ни один простой путь от корня в красно-черном дереве
не отличается от другого по длине более чем в два раза, так что красно-черные
деревья являются приближенно _сбалансированными_.
Каждый узел дерева содержит атрибуты _color_, _key_, _left_, _right_ и _p_. Если не
существует дочернего или родительского узла по отношению к данному, соответствующий указатель принимает значение `NIL`. Значения `NIL` рассматриваются как указатели на внешние узлы (листья) бинарного дерева поиска.
При этом все «нормальные» узлы, содержащие поле ключа, становятся внутренними узлами дерева[@cormen2013].

### Инвариант красно-черного дерева

Бинарное дерево поиска является красно-черным деревом, если оно удовлетворяет следующим свойствам.

1. Каждый узел является либо красным, либо черным.
2. Корень дерева является черным узлом.
3. Каждый лист дерева (`NIL`) является черным узлом.
4. Если узел красный, то оба его дочерних узла черные.
5. Для каждого узла все простые пути от него до листьев,
    являющихся потомками данного узла, содержат одно и то же количество черных узлов[@cormen2013].

### Вставка элемента


![](img/rb/13-4-cormen.pdf)

![](img/rb/13-5-cormen.pdf)

![](img/rb/13-6-cormen.pdf)

![](img/rb/13-7-cormen.pdf)

Каждый элемент вставляется вместо листа, поэтому для выбора места вставки идём от корня до тех пор, пока указатель на следующего сына не станет nil (то есть этот сын — лист). Вставляем вместо него новый элемент с нулевыми потомками и красным цветом. Теперь проверяем балансировку. Если отец нового элемента черный, то никакое из свойств дерева не нарушено. Если же он красный, то нарушается свойство 3, для исправления достаточно рассмотреть два случая:

1. "Дядя" этого узла тоже красный. Тогда, чтобы сохранить свойства 3 и 4, 
    просто перекрашиваем "отца" и "дядю" в чёрный цвет, а "деда" — в красный. В таком случае черная высота в этом поддереве одинакова для всех листьев и у всех красных вершин "отцы" черные. Проверяем, не нарушена ли балансировка. Если в результате этих перекрашиваний мы дойдём до корня, то в нём в любом случае ставим чёрный цвет, чтобы дерево удовлетворяло свойству 2.

2. "Дядя" чёрный. Если выполнить только перекрашивание,
    то может нарушиться постоянство чёрной высоты дерева по всем ветвям. Поэтому выполняем поворот. Если добавляемый узел был правым потомком, то необходимо сначала выполнить левое вращение, которое сделает его левым потомком. Таким образом, свойство 3 и постоянство черной высоты сохраняются.


### Удаление элемента

### Балансировка дерева

### Поиск в красно-черном дереве

## Хэш-таблица

### Определение

### Выбор хэш-функции

# Особенности реализации

## Структура данных

## Красно-черное дерево

Реализация Left-Leaning Red-Black Tree.

Дан интерфейс двоичного дерева поиска.

Основные методы:

- `Value get(Key key)` --- возвращает значение по заданному ключу или `null`, если такого ключа нет
- `void put(Key key, Value value)` --- сохраняет заданное значение по указанному ключу
- `Value remove(Key key)` --- удаляет заданный ключ (и связанное с ним значение, возвращая его)

Методы, основанные на порядке ключей

- `Key min()` --- возвращает минимальный ключ или `null`, если структура пустая
- `Value minValue()` --- возвращает значение, ассоцирированное с минимальным ключом, или `null`, если структура пустая
- `Key max()` --- возвращает максимальный ключ или `null`, если структура пустая
- `Value maxValue()` --- возвращает значение, ассоцирированное с максимальным ключом, или `null`, если структура пустая
- `Key floor(Key key)` --- возвращает максимальный ключ, меньший либо равный заданному, или `null`, если такого нет
- `Key ceil(Key key)` --- вовзращает минимальный ключ, больший либо равный заданному, или `null`, если такого нет

Служебные методы:

- `int size()` --- вовзращает количество узлов в дереве

### Добавление элемента в дерево

### Балансировка красно-черного дерева при добавлении в него элемента 11

### Удаление элемента

### Балансировка красно-черного дерева при удалении элемента

### Поиск элемента

### Полная очистка словаря

### Добавление в словарь текста из файла

## Хэш-таблица

Реализация хеш-таблицы с разрешением коллизий методом цепочек.

Основные методы:

- `Value get(Key key)` --- возвращает значение по заданному ключу или `null`, если такого ключа нет
- `void put(Key key, Value value)` --- сохраняет заданное значение по указанному ключу  
- `Value remove(Key key)` --- удаляет заданный ключ (и связанное с ним значение, возвращая его).
  
Служебные методы:

- `int size()` --- вовзращает количество ключей.
- `boolean isEmpty()` --- проверка на пустое множество.

### Построение хэш-таблицы

### Удаление элемента

### Поиск элемента

# Результаты работы программы

## Красно-черное дерево

```plain
Выберите, с какой структурой данных вы хотите работать:
> rb
> import /home/mhq/Desktop/onegin.txt
Введите путь до файла без пробелов:
> В словаре 10498 эл.
> find Онегин
Введите слово, чтобы найти его в словаре:
> Слово есть в словаре.
> find Ленского
Введите слово, чтобы найти его в словаре:
> Слово есть в словаре.
> find дуэль
Введите слово, чтобы найти его в словаре:
> Слово есть в словаре.
> find дуэлянт
Введите слово, чтобы найти его в словаре:
> Слова нет в словаре.
```

## Хэш-таблица

# Заключение {-}

# Список использованных источников {-}
